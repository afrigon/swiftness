AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
--------------------------------------------------- cpu-instructions-tests.a65 ---------------------------------------------------

6103 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
0000 =                  ram_top = 0
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
000a =                          org zero_page
                        ;break test interrupt save
000a : 00               irq_a   ds  1               ;a register
000b : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c : 00               adfc    ds  1               ;carry flag before op
000d : 00               ad1     ds  1               ;operand 1 - accumulator
000e : 00               ad2     ds  1               ;operand 2 - memory / immediate
000f : 00               adrl    ds  1               ;expected result bits 0-7
0010 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0011 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0013 :                  zp_bss
0013 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0017 : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0018 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001c : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0020 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0024 : 1702             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0026 : 1802                     dw  abs1+1
0028 : 1902                     dw  abs1+2
002a : 1a02                     dw  abs1+3
002c : 1b02                     dw  abs7f
002e : 1f01             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0030 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0032 : 0402                     dw  abst+1
0034 : 0502                     dw  abst+2
0036 : 0602                     dw  abst+3
0038 : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003a : 4e02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003c : 4f02                     dw  absAN+1
003e : 5002                     dw  absAN+2
0040 : 5102                     dw  absAN+3
0042 : 5202             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0044 : 5302                     dw  absEO+1
0046 : 5402                     dw  absEO+2
0048 : 5502                     dw  absEO+3
004a : 4a02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004c : 4b02                     dw  absOR+1
004e : 4c02                     dw  absOR+2
0050 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
0052 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0054 : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0056 : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0058 : 0501             sbiy2   dw  sba2-$ff
005a :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
                            if load_data_direct = 1
0208 : 2900             ex_andi and #0              ;execute immediate opcodes
020a : 60                       rts
020b : 4900             ex_eori eor #0              ;execute immediate opcodes
020d : 60                       rts
020e : 0900             ex_orai ora #0              ;execute immediate opcodes
0210 : 60                       rts
0211 : 6900             ex_adci adc #0              ;execute immediate opcodes
0213 : 60                       rts
0214 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0216 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0217 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 :                  rASL                        ;expected result ASL & ROL -carry  
0220 : 86048200         rROL    db  $86,$04,$82,0   ; "
0224 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 :                  rLSR                        ;expected result LSR & ROR -carry
0228 : 61412000         rROR    db  $61,$41,$20,0   ; "
022c : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 :                  fASL                        ;expected flags for shifts
0230 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0234 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0238 :                  fLSR
0238 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
023c : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0266 : 02800080         absflo  db  fz,fn,0,fn
026a :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
0438 : a900                     lda #0 
043a : 850c                     sta zpt         ;set low byte of indirect pointer
043c : 8d0202                   sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
043f : 8d1905                   sta range_adr   ;reset self modifying code
                              endif
0442 : 18                       clc
0443 : a209                     ldx #zp_bss-zero_page ;zeropage - write test area
0445 : 750a             gcs3    adc zero_page,x
0447 : 9004                     bcc gcs2
0449 : ee0202                   inc ram_chksm+1 ;carry to high byte
044c : 18                       clc
044d : e8               gcs2    inx
044e : d0f5                     bne gcs3
0450 : a202                     ldx #hi(abs1)   ;set high byte of indirect pointer
0452 : 860d                     stx zpt+1
0454 : a017                     ldy #lo(abs1)   ;data after write & execute test area
0456 : 710c             gcs5    adc (zpt),y
0458 : 9004                     bcc gcs4
045a : ee0202                   inc ram_chksm+1 ;carry to high byte
045d : 18                       clc
045e : c8               gcs4    iny
045f : d0f5                     bne gcs5
0461 : e8                       inx             ;advance RAM high address
0462 : 860d                     stx zpt+1
0464 : e000                     cpx #ram_top
0466 : d0ee                     bne gcs5
0468 : 8d0102                   sta ram_chksm   ;checksum complete
                            endif
                                next_test            
046b : ad0002          >            lda test_case   ;previous test
046e : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0470 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
0472 : a901            >            lda #test_num   ;*** next tests' number
0474 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0477 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0479 :                  range_loop
0479 : 88                       dey             ;next relative address
047a : 98                       tya
047b : aa                       tax             ;precharge count to end of loop
047c : 1008                     bpl range_fw    ;calculate relative address
047e : 18                       clc             ;avoid branch self or to relative address of branch
047f : 6902                     adc #2
0481 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0482 : ea                       nop
0483 : ea                       nop
0484 : ea                       nop
0485 : ea                       nop
0486 :                  range_fw
0486 : ea                       nop
0487 : ea                       nop
0488 : ea                       nop
0489 : ea                       nop
048a : ea                       nop
048b : 497f                     eor #$7f        ;complement except sign
048d : 8d1905                   sta range_adr   ;load into test target
0490 : a900                     lda #0          ;should set zero flag in status register
0492 : 4c1805                   jmp range_op
                                
0495 : ca                       dex             ; offset landing zone - backward branch too far
0496 : ca                       dex
0497 : ca                       dex
0498 : ca                       dex
0499 : ca                       dex
                                ;relative address target field with branch under test in the middle
049a : ca                       dex             ;-128 - max backward
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex
04a2 : ca                       dex             ;-120
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex
04ac : ca                       dex             ;-110
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex
04b6 : ca                       dex             ;-100
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex
04c0 : ca                       dex             ;-90
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex
04ca : ca                       dex             ;-80
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex
04d4 : ca                       dex             ;-70
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex
04de : ca                       dex             ;-60
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex
04e5 : ca                       dex
04e6 : ca                       dex
04e7 : ca                       dex
04e8 : ca                       dex             ;-50
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex
04f2 : ca                       dex             ;-40
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex
04fc : ca                       dex             ;-30
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex
0506 : ca                       dex             ;-20
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex
0510 : ca                       dex             ;-10
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex             ;-3
0518 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
0519 =                  range_adr   = *+1       ;modifiable relative address
0518 : f03e                     beq *+64        ;+64 if called without modification
051a : ca                       dex             ;+0
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex
0524 : ca                       dex             ;+10
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex
052e : ca                       dex             ;+20
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex
0538 : ca                       dex             ;+30
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex
0542 : ca                       dex             ;+40
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex
054c : ca                       dex             ;+50
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex
0556 : ca                       dex             ;+60
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex
0560 : ca                       dex             ;+70
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ca                       dex
0567 : ca                       dex
0568 : ca                       dex
0569 : ca                       dex
056a : ca                       dex             ;+80
056b : ca                       dex
056c : ca                       dex
056d : ca                       dex
056e : ca                       dex
056f : ca                       dex
0570 : ca                       dex
0571 : ca                       dex
0572 : ca                       dex
0573 : ca                       dex
0574 : ca                       dex             ;+90
0575 : ca                       dex
0576 : ca                       dex
0577 : ca                       dex
0578 : ca                       dex
0579 : ca                       dex
057a : ca                       dex
057b : ca                       dex
057c : ca                       dex
057d : ca                       dex
057e : ca                       dex             ;+100
057f : ca                       dex
0580 : ca                       dex
0581 : ca                       dex
0582 : ca                       dex
0583 : ca                       dex
0584 : ca                       dex
0585 : ca                       dex
0586 : ca                       dex
0587 : ca                       dex
0588 : ca                       dex             ;+110
0589 : ca                       dex
058a : ca                       dex
058b : ca                       dex
058c : ca                       dex
058d : ca                       dex
058e : ca                       dex
058f : ca                       dex
0590 : ca                       dex
0591 : ca                       dex
0592 : ca                       dex             ;+120
0593 : ca                       dex
0594 : ca                       dex
0595 : ca                       dex
0596 : ca                       dex
0597 : ca                       dex
0598 : ca                       dex
0599 : ea                       nop             ;offset landing zone - forward branch too far
059a : ea                       nop
059b : ea                       nop
059c : ea                       nop
059d : ea                       nop
059e : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
05a0 : 4ca005          >        jmp *           ;failed anyway
                        
05a3 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
05a4 : ea                       nop
05a5 : ea                       nop
05a6 : ea                       nop
05a7 : ea                       nop
05a8 :                  range_ok
05a8 : ea                       nop
05a9 : ea                       nop
05aa : ea                       nop
05ab : ea                       nop
05ac : ea                       nop
05ad : c000                     cpy #0
05af : f003                     beq range_end   
05b1 : 4c7904                   jmp range_loop
05b4 :                  range_end               ;range test successful
                            endif
                                next_test
05b4 : ad0002          >            lda test_case   ;previous test
05b7 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
05bb : a902            >            lda #test_num   ;*** next tests' number
05bd : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
05c0 : c001                     cpy #1          ;testing BNE true
05c2 : d003                     bne test_bne
                                trap 
05c4 : 4cc405          >        jmp *           ;failed anyway
                        
05c7 :                  test_bne
05c7 : a900                     lda #0 
05c9 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
05cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05cd : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05cf : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05d1 : c901                     cmp #1
                                trap_eq 
05d3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05d5 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05d7 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05d9 : aa                       tax 
05da : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05de : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05e0 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05e2 : e001                     cpx #1
                                trap_eq 
05e4 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05e6 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05e8 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05ea : a8                       tay 
05eb : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ef : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05f1 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05f3 : c001                     cpy #1
                                trap_eq 
05f5 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05f7 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05f9 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05fb : ad0002          >            lda test_case   ;previous test
05fe : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0600 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
0602 : a903            >            lda #test_num   ;*** next tests' number
0604 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
0607 : a2ff                     ldx #$ff        ;initialize stack
0609 : 9a                       txs
060a : a955                     lda #$55
060c : 48                       pha
060d : a9aa                     lda #$aa
060f : 48                       pha
0610 : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
0613 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0615 : ba                       tsx
0616 : 8a                       txa             ;overwrite accu
0617 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
0619 : d0fe            >        bne *           ;failed not equal (non zero)
                        
061b : 68                       pla
061c : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
061e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0620 : 68                       pla
0621 : c955                     cmp #$55
                                trap_ne
0623 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0625 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
0628 : d0fe            >        bne *           ;failed not equal (non zero)
                        
062a : ba                       tsx
062b : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
062d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
062f : ad0002          >            lda test_case   ;previous test
0632 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0634 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0636 : a904            >            lda #test_num   ;*** next tests' number
0638 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
063b : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
063d : 48              >            pha         ;use stack to load status
063e : 28              >            plp
                        
063f : 101a                     bpl nbr1        ;branches should not be taken
0641 : 501b                     bvc nbr2
0643 : 901c                     bcc nbr3
0645 : d01d                     bne nbr4
0647 : 3003                     bmi br1         ;branches should be taken
                                trap 
0649 : 4c4906          >        jmp *           ;failed anyway
                        
064c : 7003             br1     bvs br2
                                trap 
064e : 4c4e06          >        jmp *           ;failed anyway
                        
0651 : b003             br2     bcs br3
                                trap 
0653 : 4c5306          >        jmp *           ;failed anyway
                        
0656 : f00f             br3     beq br4
                                trap 
0658 : 4c5806          >        jmp *           ;failed anyway
                        
065b :                  nbr1
                                trap            ;previous bpl taken 
065b : 4c5b06          >        jmp *           ;failed anyway
                        
065e :                  nbr2
                                trap            ;previous bvc taken
065e : 4c5e06          >        jmp *           ;failed anyway
                        
0661 :                  nbr3
                                trap            ;previous bcc taken
0661 : 4c6106          >        jmp *           ;failed anyway
                        
0664 :                  nbr4
                                trap            ;previous bne taken
0664 : 4c6406          >        jmp *           ;failed anyway
                        
0667 : 08               br4     php
0668 : ba                       tsx
0669 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
066b : d0fe            >        bne *           ;failed not equal (non zero)
                        
066d : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
066e : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0670 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0672 : ba                       tsx
0673 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0675 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0677 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0679 : 48              >            pha         ;use stack to load status
067a : 28              >            plp
                        
067b : 301a                     bmi nbr11       ;branches should not be taken
067d : 701b                     bvs nbr12
067f : b01c                     bcs nbr13
0681 : f01d                     beq nbr14
0683 : 1003                     bpl br11        ;branches should be taken
                                trap 
0685 : 4c8506          >        jmp *           ;failed anyway
                        
0688 : 5003             br11    bvc br12
                                trap 
068a : 4c8a06          >        jmp *           ;failed anyway
                        
068d : 9003             br12    bcc br13
                                trap 
068f : 4c8f06          >        jmp *           ;failed anyway
                        
0692 : d00f             br13    bne br14
                                trap 
0694 : 4c9406          >        jmp *           ;failed anyway
                        
0697 :                  nbr11
                                trap            ;previous bmi taken 
0697 : 4c9706          >        jmp *           ;failed anyway
                        
069a :                  nbr12
                                trap            ;previous bvs taken 
069a : 4c9a06          >        jmp *           ;failed anyway
                        
069d :                  nbr13
                                trap            ;previous bcs taken 
069d : 4c9d06          >        jmp *           ;failed anyway
                        
06a0 :                  nbr14
                                trap            ;previous beq taken 
06a0 : 4ca006          >        jmp *           ;failed anyway
                        
06a3 : 08               br14    php
06a4 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
06a5 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
06a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
06a9 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
06ab : 48              >            pha         ;use stack to load status
06ac : 28              >            plp
                        
06ad : d002                     bne brzs1
06af : f003                     beq brzs2
06b1 :                  brzs1
                                trap            ;branch zero/non zero
06b1 : 4cb106          >        jmp *           ;failed anyway
                        
06b4 : b002             brzs2   bcs brzs3
06b6 : 9003                     bcc brzs4
06b8 :                  brzs3
                                trap            ;branch carry/no carry
06b8 : 4cb806          >        jmp *           ;failed anyway
                        
06bb : 3002             brzs4   bmi brzs5
06bd : 1003                     bpl brzs6
06bf :                  brzs5
                                trap            ;branch minus/plus
06bf : 4cbf06          >        jmp *           ;failed anyway
                        
06c2 : 7002             brzs6   bvs brzs7
06c4 : 5003                     bvc brzs8
06c6 :                  brzs7
                                trap            ;branch overflow/no overflow
06c6 : 4cc606          >        jmp *           ;failed anyway
                        
06c9 :                  brzs8
                                set_stat carry
                       >            load_flag carry
06c9 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
06cb : 48              >            pha         ;use stack to load status
06cc : 28              >            plp
                        
06cd : f002                     beq brcs1
06cf : d003                     bne brcs2
06d1 :                  brcs1
                                trap            ;branch zero/non zero
06d1 : 4cd106          >        jmp *           ;failed anyway
                        
06d4 : 9002             brcs2   bcc brcs3
06d6 : b003                     bcs brcs4
06d8 :                  brcs3
                                trap            ;branch carry/no carry
06d8 : 4cd806          >        jmp *           ;failed anyway
                        
06db : 3002             brcs4   bmi brcs5
06dd : 1003                     bpl brcs6
06df :                  brcs5
                                trap            ;branch minus/plus
06df : 4cdf06          >        jmp *           ;failed anyway
                        
06e2 : 7002             brcs6   bvs brcs7
06e4 : 5003                     bvc brcs8
06e6 :                  brcs7
                                trap            ;branch overflow/no overflow
06e6 : 4ce606          >        jmp *           ;failed anyway
                        
                        
06e9 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06e9 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
06eb : 48              >            pha         ;use stack to load status
06ec : 28              >            plp
                        
06ed : f002                     beq brmi1
06ef : d003                     bne brmi2
06f1 :                  brmi1
                                trap            ;branch zero/non zero
06f1 : 4cf106          >        jmp *           ;failed anyway
                        
06f4 : b002             brmi2   bcs brmi3
06f6 : 9003                     bcc brmi4
06f8 :                  brmi3
                                trap            ;branch carry/no carry
06f8 : 4cf806          >        jmp *           ;failed anyway
                        
06fb : 1002             brmi4   bpl brmi5
06fd : 3003                     bmi brmi6
06ff :                  brmi5
                                trap            ;branch minus/plus
06ff : 4cff06          >        jmp *           ;failed anyway
                        
0702 : 7002             brmi6   bvs brmi7
0704 : 5003                     bvc brmi8
0706 :                  brmi7
                                trap            ;branch overflow/no overflow
0706 : 4c0607          >        jmp *           ;failed anyway
                        
0709 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
0709 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
070b : 48              >            pha         ;use stack to load status
070c : 28              >            plp
                        
070d : f002                     beq brvs1
070f : d003                     bne brvs2
0711 :                  brvs1
                                trap            ;branch zero/non zero
0711 : 4c1107          >        jmp *           ;failed anyway
                        
0714 : b002             brvs2   bcs brvs3
0716 : 9003                     bcc brvs4
0718 :                  brvs3
                                trap            ;branch carry/no carry
0718 : 4c1807          >        jmp *           ;failed anyway
                        
071b : 3002             brvs4   bmi brvs5
071d : 1003                     bpl brvs6
071f :                  brvs5
                                trap            ;branch minus/plus
071f : 4c1f07          >        jmp *           ;failed anyway
                        
0722 : 5002             brvs6   bvc brvs7
0724 : 7003                     bvs brvs8
0726 :                  brvs7
                                trap            ;branch overflow/no overflow
0726 : 4c2607          >        jmp *           ;failed anyway
                        
0729 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
0729 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
072b : 48              >            pha         ;use stack to load status
072c : 28              >            plp
                        
072d : f002                     beq brzc1
072f : d003                     bne brzc2
0731 :                  brzc1
                                trap            ;branch zero/non zero
0731 : 4c3107          >        jmp *           ;failed anyway
                        
0734 : 9002             brzc2   bcc brzc3
0736 : b003                     bcs brzc4
0738 :                  brzc3
                                trap            ;branch carry/no carry
0738 : 4c3807          >        jmp *           ;failed anyway
                        
073b : 1002             brzc4   bpl brzc5
073d : 3003                     bmi brzc6
073f :                  brzc5
                                trap            ;branch minus/plus
073f : 4c3f07          >        jmp *           ;failed anyway
                        
0742 : 5002             brzc6   bvc brzc7
0744 : 7003                     bvs brzc8
0746 :                  brzc7
                                trap            ;branch overflow/no overflow
0746 : 4c4607          >        jmp *           ;failed anyway
                        
0749 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0749 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
074b : 48              >            pha         ;use stack to load status
074c : 28              >            plp
                        
074d : d002                     bne brcc1
074f : f003                     beq brcc2
0751 :                  brcc1
                                trap            ;branch zero/non zero
0751 : 4c5107          >        jmp *           ;failed anyway
                        
0754 : b002             brcc2   bcs brcc3
0756 : 9003                     bcc brcc4
0758 :                  brcc3
                                trap            ;branch carry/no carry
0758 : 4c5807          >        jmp *           ;failed anyway
                        
075b : 1002             brcc4   bpl brcc5
075d : 3003                     bmi brcc6
075f :                  brcc5
                                trap            ;branch minus/plus
075f : 4c5f07          >        jmp *           ;failed anyway
                        
0762 : 5002             brcc6   bvc brcc7
0764 : 7003                     bvs brcc8
0766 :                  brcc7
                                trap            ;branch overflow/no overflow
0766 : 4c6607          >        jmp *           ;failed anyway
                        
0769 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0769 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
076b : 48              >            pha         ;use stack to load status
076c : 28              >            plp
                        
076d : d002                     bne brpl1
076f : f003                     beq brpl2
0771 :                  brpl1
                                trap            ;branch zero/non zero
0771 : 4c7107          >        jmp *           ;failed anyway
                        
0774 : 9002             brpl2   bcc brpl3
0776 : b003                     bcs brpl4
0778 :                  brpl3
                                trap            ;branch carry/no carry
0778 : 4c7807          >        jmp *           ;failed anyway
                        
077b : 3002             brpl4   bmi brpl5
077d : 1003                     bpl brpl6
077f :                  brpl5
                                trap            ;branch minus/plus
077f : 4c7f07          >        jmp *           ;failed anyway
                        
0782 : 5002             brpl6   bvc brpl7
0784 : 7003                     bvs brpl8
0786 :                  brpl7
                                trap            ;branch overflow/no overflow
0786 : 4c8607          >        jmp *           ;failed anyway
                        
0789 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0789 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
078b : 48              >            pha         ;use stack to load status
078c : 28              >            plp
                        
078d : d002                     bne brvc1
078f : f003                     beq brvc2
0791 :                  brvc1
                                trap            ;branch zero/non zero
0791 : 4c9107          >        jmp *           ;failed anyway
                        
0794 : 9002             brvc2   bcc brvc3
0796 : b003                     bcs brvc4
0798 :                  brvc3
                                trap            ;branch carry/no carry
0798 : 4c9807          >        jmp *           ;failed anyway
                        
079b : 1002             brvc4   bpl brvc5
079d : 3003                     bmi brvc6
079f :                  brvc5
                                trap            ;branch minus/plus
079f : 4c9f07          >        jmp *           ;failed anyway
                        
07a2 : 7002             brvc6   bvs brvc7
07a4 : 5003                     bvc brvc8
07a6 :                  brvc7
                                trap            ;branch overflow/no overflow
07a6 : 4ca607          >        jmp *           ;failed anyway
                        
07a9 :                  brvc8
                                next_test
07a9 : ad0002          >            lda test_case   ;previous test
07ac : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
07ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
07b0 : a905            >            lda #test_num   ;*** next tests' number
07b2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
07b5 : a255                     ldx #$55        ;x & y protected
07b7 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
07b9 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07bb : 48              >            pha         ;use stack to load status
07bc : a901            >            lda #1     ;precharge accu
07be : 28              >            plp
                        
07bf : 48                       pha
                                tst_a 1,$ff
07c0 : 08              >            php         ;save flags
07c1 : c901            >            cmp #1     ;test result
                       >            trap_ne
07c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07c5 : 68              >            pla         ;load status
07c6 : 48              >            pha
                       >            cmp_flag $ff
07c7 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
07cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07ce : 48              >            pha         ;use stack to load status
07cf : a900            >            lda #0     ;precharge accu
07d1 : 28              >            plp
                        
07d2 : 48                       pha
                                tst_a 0,0
07d3 : 08              >            php         ;save flags
07d4 : c900            >            cmp #0     ;test result
                       >            trap_ne
07d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d8 : 68              >            pla         ;load status
07d9 : 48              >            pha
                       >            cmp_flag 0
07da : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07df : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07e1 : 48              >            pha         ;use stack to load status
07e2 : a9ff            >            lda #$ff     ;precharge accu
07e4 : 28              >            plp
                        
07e5 : 48                       pha
                                tst_a $ff,$ff
07e6 : 08              >            php         ;save flags
07e7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07eb : 68              >            pla         ;load status
07ec : 48              >            pha
                       >            cmp_flag $ff
07ed : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07f2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07f4 : 48              >            pha         ;use stack to load status
07f5 : a901            >            lda #1     ;precharge accu
07f7 : 28              >            plp
                        
07f8 : 48                       pha
                                tst_a 1,0
07f9 : 08              >            php         ;save flags
07fa : c901            >            cmp #1     ;test result
                       >            trap_ne
07fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07fe : 68              >            pla         ;load status
07ff : 48              >            pha
                       >            cmp_flag 0
0800 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
0805 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0807 : 48              >            pha         ;use stack to load status
0808 : a900            >            lda #0     ;precharge accu
080a : 28              >            plp
                        
080b : 48                       pha
                                tst_a 0,$ff
080c : 08              >            php         ;save flags
080d : c900            >            cmp #0     ;test result
                       >            trap_ne
080f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0811 : 68              >            pla         ;load status
0812 : 48              >            pha
                       >            cmp_flag $ff
0813 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0818 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
081a : 48              >            pha         ;use stack to load status
081b : a9ff            >            lda #$ff     ;precharge accu
081d : 28              >            plp
                        
081e : 48                       pha
                                tst_a $ff,0
081f : 08              >            php         ;save flags
0820 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0822 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0824 : 68              >            pla         ;load status
0825 : 48              >            pha
                       >            cmp_flag 0
0826 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
082b : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
082d : 48              >            pha         ;use stack to load status
082e : a900            >            lda #0     ;precharge accu
0830 : 28              >            plp
                        
0831 : 68                       pla
                                tst_a $ff,$ff-zero
0832 : 08              >            php         ;save flags
0833 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0835 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0837 : 68              >            pla         ;load status
0838 : 48              >            pha
                       >            cmp_flag $ff-zero
0839 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
083e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0840 : 48              >            pha         ;use stack to load status
0841 : a9ff            >            lda #$ff     ;precharge accu
0843 : 28              >            plp
                        
0844 : 68                       pla
                                tst_a 0,zero
0845 : 08              >            php         ;save flags
0846 : c900            >            cmp #0     ;test result
                       >            trap_ne
0848 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
084a : 68              >            pla         ;load status
084b : 48              >            pha
                       >            cmp_flag zero
084c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
084e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0850 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
0851 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0853 : 48              >            pha         ;use stack to load status
0854 : a9fe            >            lda #$fe     ;precharge accu
0856 : 28              >            plp
                        
0857 : 68                       pla
                                tst_a 1,$ff-zero-minus
0858 : 08              >            php         ;save flags
0859 : c901            >            cmp #1     ;test result
                       >            trap_ne
085b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
085d : 68              >            pla         ;load status
085e : 48              >            pha
                       >            cmp_flag $ff-zero-minus
085f : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0861 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0863 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0864 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0866 : 48              >            pha         ;use stack to load status
0867 : a900            >            lda #0     ;precharge accu
0869 : 28              >            plp
                        
086a : 68                       pla
                                tst_a $ff,minus
086b : 08              >            php         ;save flags
086c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
086e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0870 : 68              >            pla         ;load status
0871 : 48              >            pha
                       >            cmp_flag minus
0872 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0874 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0876 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0877 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0879 : 48              >            pha         ;use stack to load status
087a : a9ff            >            lda #$ff     ;precharge accu
087c : 28              >            plp
                        
087d : 68                       pla
                                tst_a 0,$ff-minus
087e : 08              >            php         ;save flags
087f : c900            >            cmp #0     ;test result
                       >            trap_ne
0881 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0883 : 68              >            pla         ;load status
0884 : 48              >            pha
                       >            cmp_flag $ff-minus
0885 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0887 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0889 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
088a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
088c : 48              >            pha         ;use stack to load status
088d : a9fe            >            lda #$fe     ;precharge accu
088f : 28              >            plp
                        
0890 : 68                       pla
                                tst_a 1,0
0891 : 08              >            php         ;save flags
0892 : c901            >            cmp #1     ;test result
                       >            trap_ne
0894 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0896 : 68              >            pla         ;load status
0897 : 48              >            pha
                       >            cmp_flag 0
0898 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
089a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089c : 28              >            plp         ;restore status
                        
089d : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
089f : d0fe            >        bne *           ;failed not equal (non zero)
                        
08a1 : c0aa                     cpy #$aa
                                trap_ne
08a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08a5 : ad0002          >            lda test_case   ;previous test
08a8 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
08ac : a906            >            lda #test_num   ;*** next tests' number
08ae : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
08b1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08b3 : 48              >            pha         ;use stack to load status
08b4 : a93c            >            lda #$3c     ;precharge accu
08b6 : 28              >            plp
                        
08b7 : 49c3                     eor #$c3
                                tst_a $ff,fn
08b9 : 08              >            php         ;save flags
08ba : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
08bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08be : 68              >            pla         ;load status
08bf : 48              >            pha
                       >            cmp_flag fn
08c0 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c4 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
08c5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08c7 : 48              >            pha         ;use stack to load status
08c8 : a9c3            >            lda #$c3     ;precharge accu
08ca : 28              >            plp
                        
08cb : 49c3                     eor #$c3
                                tst_a 0,fz
08cd : 08              >            php         ;save flags
08ce : c900            >            cmp #0     ;test result
                       >            trap_ne
08d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08d2 : 68              >            pla         ;load status
08d3 : 48              >            pha
                       >            cmp_flag fz
08d4 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08d8 : 28              >            plp         ;restore status
                        
                                next_test
08d9 : ad0002          >            lda test_case   ;previous test
08dc : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08e0 : a907            >            lda #test_num   ;*** next tests' number
08e2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08e5 : a224                     ldx #$24
08e7 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08e9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08eb : 48              >            pha         ;use stack to load status
08ec : a918            >            lda #$18     ;precharge accu
08ee : 28              >            plp
                        
08ef : ea                       nop
                                tst_a $18,0
08f0 : 08              >            php         ;save flags
08f1 : c918            >            cmp #$18     ;test result
                       >            trap_ne
08f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08f5 : 68              >            pla         ;load status
08f6 : 48              >            pha
                       >            cmp_flag 0
08f7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08fb : 28              >            plp         ;restore status
                        
08fc : e024                     cpx #$24
                                trap_ne
08fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0900 : c042                     cpy #$42
                                trap_ne
0902 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0904 : a2db                     ldx #$db
0906 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
0908 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
090a : 48              >            pha         ;use stack to load status
090b : a9e7            >            lda #$e7     ;precharge accu
090d : 28              >            plp
                        
090e : ea                       nop
                                tst_a $e7,$ff
090f : 08              >            php         ;save flags
0910 : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
0912 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0914 : 68              >            pla         ;load status
0915 : 48              >            pha
                       >            cmp_flag $ff
0916 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0918 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
091a : 28              >            plp         ;restore status
                        
091b : e0db                     cpx #$db
                                trap_ne
091d : d0fe            >        bne *           ;failed not equal (non zero)
                        
091f : c0bd                     cpy #$bd
                                trap_ne
0921 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0923 : ad0002          >            lda test_case   ;previous test
0926 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0928 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
092a : a908            >            lda #test_num   ;*** next tests' number
092c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
092f : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
0931 : 48              >            pha         ;use stack to load status
0932 : 28              >            plp
                        
0933 : a946                     lda #'F'
0935 : a241                     ldx #'A'
0937 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0939 : 4c2f35                   jmp test_far
093c : ea                       nop
093d : ea                       nop
                                trap_ne         ;runover protection
093e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0940 : e8                       inx
0941 : e8                       inx
0942 :                  far_ret 
                                trap_eq         ;returned flags OK?
0942 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0944 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0946 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0948 : 50fe            >        bvc *           ;failed overflow clear
                        
094a : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
094c : d0fe            >        bne *           ;failed not equal (non zero)
                        
094e : e042                     cpx #('A'+1)
                                trap_ne
0950 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0952 : c04f                     cpy #('R'-3)
                                trap_ne
0954 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0956 : ca                       dex
0957 : c8                       iny
0958 : c8                       iny
0959 : c8                       iny
095a : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
095c : 4c6509                   jmp test_near
095f : ea                       nop
0960 : ea                       nop
                                trap_ne         ;runover protection
0961 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0963 : e8                       inx
0964 : e8                       inx
0965 :                  test_near
                                trap_eq         ;passed flags OK?
0965 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0967 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0969 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
096b : 50fe            >        bvc *           ;failed overflow clear
                        
096d : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
096f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0971 : e041                     cpx #'A'
                                trap_ne
0973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0975 : c052                     cpy #'R'
                                trap_ne
0977 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0979 : ad0002          >            lda test_case   ;previous test
097c : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
097e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0980 : a909            >            lda #test_num   ;*** next tests' number
0982 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0985 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0987 : 48              >            pha         ;use stack to load status
0988 : 28              >            plp
                        
0989 : a949                     lda #'I'
098b : a24e                     ldx #'N'
098d : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
098f : 6c5e35                   jmp (ptr_tst_ind)
0992 : ea                       nop
                                trap_ne         ;runover protection
0993 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0995 : 88                       dey
0996 : 88                       dey
0997 :                  ind_ret 
0997 : 08                       php             ;either SP or Y count will fail, if we do not hit
0998 : 88                       dey
0999 : 88                       dey
099a : 88                       dey
099b : 28                       plp
                                trap_eq         ;returned flags OK?
099c : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
099e : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09a0 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09a2 : 50fe            >        bvc *           ;failed overflow clear
                        
09a4 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
09a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09a8 : e04f                     cpx #('N'+1)
                                trap_ne
09aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ac : c03e                     cpy #('D'-6)
                                trap_ne
09ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b0 : ba                       tsx             ;SP check
09b1 : e0ff                     cpx #$ff
                                trap_ne
09b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09b5 : ad0002          >            lda test_case   ;previous test
09b8 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
09bc : a90a            >            lda #test_num   ;*** next tests' number
09be : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
09c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09c3 : 48              >            pha         ;use stack to load status
09c4 : 28              >            plp
                        
09c5 : a94a                     lda #'J'
09c7 : a253                     ldx #'S'
09c9 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
09cb : 209d35                   jsr test_jsr
09cd =                  jsr_ret = *-1           ;last address of jsr = return address
09ce : 08                       php             ;either SP or Y count will fail, if we do not hit
09cf : 88                       dey
09d0 : 88                       dey
09d1 : 88                       dey
09d2 : 28                       plp
                                trap_eq         ;returned flags OK?
09d3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09d5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09d7 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09d9 : 50fe            >        bvc *           ;failed overflow clear
                        
09db : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
09df : e054                     cpx #('S'+1)
                                trap_ne
09e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e3 : c04c                     cpy #('R'-6)
                                trap_ne
09e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e7 : ba                       tsx             ;sp?
09e8 : e0ff                     cpx #$ff
                                trap_ne
09ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09ec : ad0002          >            lda test_case   ;previous test
09ef : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09f3 : a90b            >            lda #test_num   ;*** next tests' number
09f5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
09f8 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
09fa : 48                       pha
09fb : a942                     lda #'B'
09fd : a252                     ldx #'R'
09ff : a04b                     ldy #'K'
0a01 : 28                       plp             ;N=0, V=0, Z=0, C=0
0a02 : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
0a03 : 88                       dey             ;should not be executed
0a04 :                  brk_ret0                ;address of break return
0a04 : 08                       php             ;either SP or Y count will fail, if we do not hit
0a05 : 88                       dey
0a06 : 88                       dey
0a07 : 88                       dey
0a08 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a0c : e053                     cpx #'R'+1
                                trap_ne
0a0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a10 : c045                     cpy #'K'-6
                                trap_ne
0a12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a14 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
0a15 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a19 : ba                       tsx             ;sp?
0a1a : e0ff                     cpx #$ff
                                trap_ne
0a1c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
0a1e : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
0a20 : 48                       pha
0a21 : a9bd                     lda #$ff-'B'
0a23 : a2ad                     ldx #$ff-'R'
0a25 : a0b4                     ldy #$ff-'K'
0a27 : 28                       plp             ;N=1, V=1, Z=1, C=1
0a28 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
0a29 : 88                       dey             ;should not be executed
0a2a :                  brk_ret1                ;address of break return
0a2a : 08                       php             ;either SP or Y count will fail, if we do not hit
0a2b : 88                       dey
0a2c : 88                       dey
0a2d : 88                       dey
0a2e : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a30 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a32 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0a34 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a36 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0a38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a3a : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0a3b : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a3d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a3f : ba                       tsx             ;sp?
0a40 : e0ff                     cpx #$ff
                                trap_ne
0a42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a44 : ad0002          >            lda test_case   ;previous test
0a47 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0a4b : a90c            >            lda #test_num   ;*** next tests' number
0a4d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0a50 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a52 : 48              >            pha         ;use stack to load status
0a53 : 28              >            plp
                        
0a54 : 18                       clc
                                tst_stat $ff-carry
0a55 : 08              >            php         ;save status
0a56 : 68              >            pla         ;use stack to retrieve status
0a57 : 48              >            pha
                       >            cmp_flag $ff-carry
0a58 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a5c : 28              >            plp         ;restore status
                        
0a5d : 38                       sec
                                tst_stat $ff
0a5e : 08              >            php         ;save status
0a5f : 68              >            pla         ;use stack to retrieve status
0a60 : 48              >            pha
                       >            cmp_flag $ff
0a61 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a65 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a66 : 58                       cli
                                tst_stat $ff-intdis
0a67 : 08              >            php         ;save status
0a68 : 68              >            pla         ;use stack to retrieve status
0a69 : 48              >            pha
                       >            cmp_flag $ff-intdis
0a6a : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6e : 28              >            plp         ;restore status
                        
0a6f : 78                       sei
                                tst_stat $ff
0a70 : 08              >            php         ;save status
0a71 : 68              >            pla         ;use stack to retrieve status
0a72 : 48              >            pha
                       >            cmp_flag $ff
0a73 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a77 : 28              >            plp         ;restore status
                        
                            endif
0a78 : d8                       cld
                                tst_stat $ff-decmode
0a79 : 08              >            php         ;save status
0a7a : 68              >            pla         ;use stack to retrieve status
0a7b : 48              >            pha
                       >            cmp_flag $ff-decmode
0a7c : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a80 : 28              >            plp         ;restore status
                        
0a81 : f8                       sed
                                tst_stat $ff
0a82 : 08              >            php         ;save status
0a83 : 68              >            pla         ;use stack to retrieve status
0a84 : 48              >            pha
                       >            cmp_flag $ff
0a85 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a89 : 28              >            plp         ;restore status
                        
0a8a : b8                       clv
                                tst_stat $ff-overfl
0a8b : 08              >            php         ;save status
0a8c : 68              >            pla         ;use stack to retrieve status
0a8d : 48              >            pha
                       >            cmp_flag $ff-overfl
0a8e : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a92 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a93 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a95 : 48              >            pha         ;use stack to load status
0a96 : 28              >            plp
                        
                                tst_stat 0
0a97 : 08              >            php         ;save status
0a98 : 68              >            pla         ;use stack to retrieve status
0a99 : 48              >            pha
                       >            cmp_flag 0
0a9a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9e : 28              >            plp         ;restore status
                        
0a9f : 38                       sec
                                tst_stat carry
0aa0 : 08              >            php         ;save status
0aa1 : 68              >            pla         ;use stack to retrieve status
0aa2 : 48              >            pha
                       >            cmp_flag carry
0aa3 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa7 : 28              >            plp         ;restore status
                        
0aa8 : 18                       clc
                                tst_stat 0  
0aa9 : 08              >            php         ;save status
0aaa : 68              >            pla         ;use stack to retrieve status
0aab : 48              >            pha
                       >            cmp_flag 0  
0aac : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab0 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0ab1 : 78                       sei
                                tst_stat intdis
0ab2 : 08              >            php         ;save status
0ab3 : 68              >            pla         ;use stack to retrieve status
0ab4 : 48              >            pha
                       >            cmp_flag intdis
0ab5 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab9 : 28              >            plp         ;restore status
                        
0aba : 58                       cli
                                tst_stat 0
0abb : 08              >            php         ;save status
0abc : 68              >            pla         ;use stack to retrieve status
0abd : 48              >            pha
                       >            cmp_flag 0
0abe : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac2 : 28              >            plp         ;restore status
                        
                            endif  
0ac3 : f8                       sed
                                tst_stat decmode
0ac4 : 08              >            php         ;save status
0ac5 : 68              >            pla         ;use stack to retrieve status
0ac6 : 48              >            pha
                       >            cmp_flag decmode
0ac7 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ac9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acb : 28              >            plp         ;restore status
                        
0acc : d8                       cld
                                tst_stat 0  
0acd : 08              >            php         ;save status
0ace : 68              >            pla         ;use stack to retrieve status
0acf : 48              >            pha
                       >            cmp_flag 0  
0ad0 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad4 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0ad5 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0ad7 : 48              >            pha         ;use stack to load status
0ad8 : 28              >            plp
                        
                                tst_stat overfl
0ad9 : 08              >            php         ;save status
0ada : 68              >            pla         ;use stack to retrieve status
0adb : 48              >            pha
                       >            cmp_flag overfl
0adc : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ade : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae0 : 28              >            plp         ;restore status
                        
0ae1 : b8                       clv
                                tst_stat 0
0ae2 : 08              >            php         ;save status
0ae3 : 68              >            pla         ;use stack to retrieve status
0ae4 : 48              >            pha
                       >            cmp_flag 0
0ae5 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ae7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae9 : 28              >            plp         ;restore status
                        
                                next_test
0aea : ad0002          >            lda test_case   ;previous test
0aed : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0aef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0af1 : a90d            >            lda #test_num   ;*** next tests' number
0af3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0af6 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0af8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0afa : 48              >            pha         ;use stack to load status
0afb : 28              >            plp
                        
0afc : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0afd : 08              >            php         ;save flags
0afe : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b02 : 68              >            pla         ;load status
0b03 : 48              >            pha
                       >            cmp_flag $ff-zero
0b04 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b08 : 28              >            plp         ;restore status
                        
0b09 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0b0a : 08              >            php         ;save flags
0b0b : e000            >            cpx #0     ;test result
                       >            trap_ne
0b0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0f : 68              >            pla         ;load status
0b10 : 48              >            pha
                       >            cmp_flag $ff-minus
0b11 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b15 : 28              >            plp         ;restore status
                        
0b16 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0b17 : 08              >            php         ;save flags
0b18 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1c : 68              >            pla         ;load status
0b1d : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b1e : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b22 : 28              >            plp         ;restore status
                        
0b23 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0b24 : 08              >            php         ;save flags
0b25 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b29 : 68              >            pla         ;load status
0b2a : 48              >            pha
                       >            cmp_flag $ff-minus
0b2b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2f : 28              >            plp         ;restore status
                        
0b30 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0b31 : 08              >            php         ;save flags
0b32 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b36 : 68              >            pla         ;load status
0b37 : 48              >            pha
                       >            cmp_flag $ff-zero
0b38 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3c : 28              >            plp         ;restore status
                        
0b3d : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0b3e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b40 : 48              >            pha         ;use stack to load status
0b41 : 28              >            plp
                        
0b42 : e8                       inx             ;ff
                                tst_x $ff,minus
0b43 : 08              >            php         ;save flags
0b44 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b48 : 68              >            pla         ;load status
0b49 : 48              >            pha
                       >            cmp_flag minus
0b4a : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4e : 28              >            plp         ;restore status
                        
0b4f : e8                       inx             ;00
                                tst_x 0,zero
0b50 : 08              >            php         ;save flags
0b51 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b55 : 68              >            pla         ;load status
0b56 : 48              >            pha
                       >            cmp_flag zero
0b57 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5b : 28              >            plp         ;restore status
                        
0b5c : e8                       inx             ;01
                                tst_x 1,0
0b5d : 08              >            php         ;save flags
0b5e : e001            >            cpx #1     ;test result
                       >            trap_ne
0b60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b62 : 68              >            pla         ;load status
0b63 : 48              >            pha
                       >            cmp_flag 0
0b64 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b68 : 28              >            plp         ;restore status
                        
0b69 : ca                       dex             ;00
                                tst_x 0,zero
0b6a : 08              >            php         ;save flags
0b6b : e000            >            cpx #0     ;test result
                       >            trap_ne
0b6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6f : 68              >            pla         ;load status
0b70 : 48              >            pha
                       >            cmp_flag zero
0b71 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b75 : 28              >            plp         ;restore status
                        
0b76 : ca                       dex             ;ff
                                tst_x $ff,minus
0b77 : 08              >            php         ;save flags
0b78 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7c : 68              >            pla         ;load status
0b7d : 48              >            pha
                       >            cmp_flag minus
0b7e : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b82 : 28              >            plp         ;restore status
                        
                        
0b83 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b87 : 48              >            pha         ;use stack to load status
0b88 : 28              >            plp
                        
0b89 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b8a : 08              >            php         ;save flags
0b8b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8f : 68              >            pla         ;load status
0b90 : 48              >            pha
                       >            cmp_flag $ff-zero
0b91 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b95 : 28              >            plp         ;restore status
                        
0b96 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b97 : 08              >            php         ;save flags
0b98 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9c : 68              >            pla         ;load status
0b9d : 48              >            pha
                       >            cmp_flag $ff-minus
0b9e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ba0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba2 : 28              >            plp         ;restore status
                        
0ba3 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0ba4 : 08              >            php         ;save flags
0ba5 : c001            >            cpy #1     ;test result
                       >            trap_ne
0ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba9 : 68              >            pla         ;load status
0baa : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bab : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0baf : 28              >            plp         ;restore status
                        
0bb0 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0bb1 : 08              >            php         ;save flags
0bb2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb6 : 68              >            pla         ;load status
0bb7 : 48              >            pha
                       >            cmp_flag $ff-minus
0bb8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbc : 28              >            plp         ;restore status
                        
0bbd : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0bbe : 08              >            php         ;save flags
0bbf : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc3 : 68              >            pla         ;load status
0bc4 : 48              >            pha
                       >            cmp_flag $ff-zero
0bc5 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc9 : 28              >            plp         ;restore status
                        
0bca : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0bcb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bcd : 48              >            pha         ;use stack to load status
0bce : 28              >            plp
                        
0bcf : c8                       iny             ;ff
                                tst_y $ff,0+minus
0bd0 : 08              >            php         ;save flags
0bd1 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd5 : 68              >            pla         ;load status
0bd6 : 48              >            pha
                       >            cmp_flag 0+minus
0bd7 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bdb : 28              >            plp         ;restore status
                        
0bdc : c8                       iny             ;00
                                tst_y 0,zero
0bdd : 08              >            php         ;save flags
0bde : c000            >            cpy #0     ;test result
                       >            trap_ne
0be0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be2 : 68              >            pla         ;load status
0be3 : 48              >            pha
                       >            cmp_flag zero
0be4 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be8 : 28              >            plp         ;restore status
                        
0be9 : c8                       iny             ;01
                                tst_y 1,0
0bea : 08              >            php         ;save flags
0beb : c001            >            cpy #1     ;test result
                       >            trap_ne
0bed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bef : 68              >            pla         ;load status
0bf0 : 48              >            pha
                       >            cmp_flag 0
0bf1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bf3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf5 : 28              >            plp         ;restore status
                        
0bf6 : 88                       dey             ;00
                                tst_y 0,zero
0bf7 : 08              >            php         ;save flags
0bf8 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfc : 68              >            pla         ;load status
0bfd : 48              >            pha
                       >            cmp_flag zero
0bfe : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c02 : 28              >            plp         ;restore status
                        
0c03 : 88                       dey             ;ff
                                tst_y $ff,minus
0c04 : 08              >            php         ;save flags
0c05 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c09 : 68              >            pla         ;load status
0c0a : 48              >            pha
                       >            cmp_flag minus
0c0b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0f : 28              >            plp         ;restore status
                        
                                        
0c10 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0c12 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c14 : 48              >            pha         ;use stack to load status
0c15 : 28              >            plp
                        
0c16 : 8a                       txa
                                tst_a $ff,$ff-zero
0c17 : 08              >            php         ;save flags
0c18 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1c : 68              >            pla         ;load status
0c1d : 48              >            pha
                       >            cmp_flag $ff-zero
0c1e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c22 : 28              >            plp         ;restore status
                        
0c23 : 08                       php
0c24 : e8                       inx             ;00
0c25 : 28                       plp
0c26 : 8a                       txa
                                tst_a 0,$ff-minus
0c27 : 08              >            php         ;save flags
0c28 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2c : 68              >            pla         ;load status
0c2d : 48              >            pha
                       >            cmp_flag $ff-minus
0c2e : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c32 : 28              >            plp         ;restore status
                        
0c33 : 08                       php
0c34 : e8                       inx             ;01
0c35 : 28                       plp
0c36 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0c37 : 08              >            php         ;save flags
0c38 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3c : 68              >            pla         ;load status
0c3d : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c3e : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c42 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c43 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c45 : 48              >            pha         ;use stack to load status
0c46 : 28              >            plp
                        
0c47 : 8a                       txa
                                tst_a 1,0
0c48 : 08              >            php         ;save flags
0c49 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4d : 68              >            pla         ;load status
0c4e : 48              >            pha
                       >            cmp_flag 0
0c4f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c53 : 28              >            plp         ;restore status
                        
0c54 : 08                       php
0c55 : ca                       dex             ;00
0c56 : 28                       plp
0c57 : 8a                       txa
                                tst_a 0,zero
0c58 : 08              >            php         ;save flags
0c59 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5d : 68              >            pla         ;load status
0c5e : 48              >            pha
                       >            cmp_flag zero
0c5f : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c63 : 28              >            plp         ;restore status
                        
0c64 : 08                       php
0c65 : ca                       dex             ;ff
0c66 : 28                       plp
0c67 : 8a                       txa
                                tst_a $ff,minus
0c68 : 08              >            php         ;save flags
0c69 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6d : 68              >            pla         ;load status
0c6e : 48              >            pha
                       >            cmp_flag minus
0c6f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c73 : 28              >            plp         ;restore status
                        
                                                
0c74 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0c76 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c78 : 48              >            pha         ;use stack to load status
0c79 : 28              >            plp
                        
0c7a : 98                       tya
                                tst_a $ff,$ff-zero
0c7b : 08              >            php         ;save flags
0c7c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c80 : 68              >            pla         ;load status
0c81 : 48              >            pha
                       >            cmp_flag $ff-zero
0c82 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c86 : 28              >            plp         ;restore status
                        
0c87 : 08                       php
0c88 : c8                       iny             ;00
0c89 : 28                       plp
0c8a : 98                       tya
                                tst_a 0,$ff-minus
0c8b : 08              >            php         ;save flags
0c8c : c900            >            cmp #0     ;test result
                       >            trap_ne
0c8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c90 : 68              >            pla         ;load status
0c91 : 48              >            pha
                       >            cmp_flag $ff-minus
0c92 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c96 : 28              >            plp         ;restore status
                        
0c97 : 08                       php
0c98 : c8                       iny             ;01
0c99 : 28                       plp
0c9a : 98                       tya
                                tst_a 1,$ff-minus-zero
0c9b : 08              >            php         ;save flags
0c9c : c901            >            cmp #1     ;test result
                       >            trap_ne
0c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca0 : 68              >            pla         ;load status
0ca1 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0ca2 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca6 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0ca7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ca9 : 48              >            pha         ;use stack to load status
0caa : 28              >            plp
                        
0cab : 98                       tya
                                tst_a 1,0
0cac : 08              >            php         ;save flags
0cad : c901            >            cmp #1     ;test result
                       >            trap_ne
0caf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb1 : 68              >            pla         ;load status
0cb2 : 48              >            pha
                       >            cmp_flag 0
0cb3 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb7 : 28              >            plp         ;restore status
                        
0cb8 : 08                       php
0cb9 : 88                       dey             ;00
0cba : 28                       plp
0cbb : 98                       tya
                                tst_a 0,zero
0cbc : 08              >            php         ;save flags
0cbd : c900            >            cmp #0     ;test result
                       >            trap_ne
0cbf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc1 : 68              >            pla         ;load status
0cc2 : 48              >            pha
                       >            cmp_flag zero
0cc3 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc7 : 28              >            plp         ;restore status
                        
0cc8 : 08                       php
0cc9 : 88                       dey             ;ff
0cca : 28                       plp
0ccb : 98                       tya
                                tst_a $ff,minus
0ccc : 08              >            php         ;save flags
0ccd : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0ccf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd1 : 68              >            pla         ;load status
0cd2 : 48              >            pha
                       >            cmp_flag minus
0cd3 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd7 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0cd8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0cda : 48                       pha
0cdb : a2ff                     ldx #$ff        ;ff
0cdd : 8a                       txa
0cde : 28                       plp             
0cdf : a8                       tay
                                tst_y $ff,$ff-zero
0ce0 : 08              >            php         ;save flags
0ce1 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ce3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce5 : 68              >            pla         ;load status
0ce6 : 48              >            pha
                       >            cmp_flag $ff-zero
0ce7 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ceb : 28              >            plp         ;restore status
                        
0cec : 08                       php
0ced : e8                       inx             ;00
0cee : 8a                       txa
0cef : 28                       plp
0cf0 : a8                       tay
                                tst_y 0,$ff-minus
0cf1 : 08              >            php         ;save flags
0cf2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0cf4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf6 : 68              >            pla         ;load status
0cf7 : 48              >            pha
                       >            cmp_flag $ff-minus
0cf8 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfc : 28              >            plp         ;restore status
                        
0cfd : 08                       php
0cfe : e8                       inx             ;01
0cff : 8a                       txa
0d00 : 28                       plp
0d01 : a8                       tay
                                tst_y 1,$ff-minus-zero
0d02 : 08              >            php         ;save flags
0d03 : c001            >            cpy #1     ;test result
                       >            trap_ne
0d05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d07 : 68              >            pla         ;load status
0d08 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d09 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0d : 28              >            plp         ;restore status
                        
                                load_flag 0
0d0e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0d10 : 48                       pha
0d11 : a900                     lda #0
0d13 : 8a                       txa
0d14 : 28                       plp
0d15 : a8                       tay
                                tst_y 1,0
0d16 : 08              >            php         ;save flags
0d17 : c001            >            cpy #1     ;test result
                       >            trap_ne
0d19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1b : 68              >            pla         ;load status
0d1c : 48              >            pha
                       >            cmp_flag 0
0d1d : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d1f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d21 : 28              >            plp         ;restore status
                        
0d22 : 08                       php
0d23 : ca                       dex             ;00
0d24 : 8a                       txa
0d25 : 28                       plp
0d26 : a8                       tay
                                tst_y 0,zero
0d27 : 08              >            php         ;save flags
0d28 : c000            >            cpy #0     ;test result
                       >            trap_ne
0d2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2c : 68              >            pla         ;load status
0d2d : 48              >            pha
                       >            cmp_flag zero
0d2e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d32 : 28              >            plp         ;restore status
                        
0d33 : 08                       php
0d34 : ca                       dex             ;ff
0d35 : 8a                       txa
0d36 : 28                       plp
0d37 : a8                       tay
                                tst_y $ff,minus
0d38 : 08              >            php         ;save flags
0d39 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0d3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d3d : 68              >            pla         ;load status
0d3e : 48              >            pha
                       >            cmp_flag minus
0d3f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d43 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0d44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0d46 : 48                       pha
0d47 : a0ff                     ldy #$ff        ;ff
0d49 : 98                       tya
0d4a : 28                       plp
0d4b : aa                       tax
                                tst_x $ff,$ff-zero
0d4c : 08              >            php         ;save flags
0d4d : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d51 : 68              >            pla         ;load status
0d52 : 48              >            pha
                       >            cmp_flag $ff-zero
0d53 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d57 : 28              >            plp         ;restore status
                        
0d58 : 08                       php
0d59 : c8                       iny             ;00
0d5a : 98                       tya
0d5b : 28                       plp
0d5c : aa                       tax
                                tst_x 0,$ff-minus
0d5d : 08              >            php         ;save flags
0d5e : e000            >            cpx #0     ;test result
                       >            trap_ne
0d60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d62 : 68              >            pla         ;load status
0d63 : 48              >            pha
                       >            cmp_flag $ff-minus
0d64 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d68 : 28              >            plp         ;restore status
                        
0d69 : 08                       php
0d6a : c8                       iny             ;01
0d6b : 98                       tya
0d6c : 28                       plp
0d6d : aa                       tax
                                tst_x 1,$ff-minus-zero
0d6e : 08              >            php         ;save flags
0d6f : e001            >            cpx #1     ;test result
                       >            trap_ne
0d71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d73 : 68              >            pla         ;load status
0d74 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d75 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d79 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d7a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0d7c : 48                       pha
0d7d : a900                     lda #0          ;preset status
0d7f : 98                       tya
0d80 : 28                       plp
0d81 : aa                       tax
                                tst_x 1,0
0d82 : 08              >            php         ;save flags
0d83 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d87 : 68              >            pla         ;load status
0d88 : 48              >            pha
                       >            cmp_flag 0
0d89 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d8b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d8d : 28              >            plp         ;restore status
                        
0d8e : 08                       php
0d8f : 88                       dey             ;00
0d90 : 98                       tya
0d91 : 28                       plp
0d92 : aa                       tax
                                tst_x 0,zero
0d93 : 08              >            php         ;save flags
0d94 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d98 : 68              >            pla         ;load status
0d99 : 48              >            pha
                       >            cmp_flag zero
0d9a : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d9e : 28              >            plp         ;restore status
                        
0d9f : 08                       php
0da0 : 88                       dey             ;ff
0da1 : 98                       tya
0da2 : 28                       plp
0da3 : aa                       tax
                                tst_x $ff,minus
0da4 : 08              >            php         ;save flags
0da5 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0da7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0da9 : 68              >            pla         ;load status
0daa : 48              >            pha
                       >            cmp_flag minus
0dab : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0dad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0daf : 28              >            plp         ;restore status
                        
                                next_test
0db0 : ad0002          >            lda test_case   ;previous test
0db3 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0db5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0db7 : a90e            >            lda #test_num   ;*** next tests' number
0db9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0dbc : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0dbe : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dc0 : 48              >            pha         ;use stack to load status
0dc1 : 28              >            plp
                        
0dc2 : 9a                       txs
0dc3 : 08                       php
0dc4 : ad0101                   lda $101
                                cmp_flag $ff
0dc7 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dc9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dcb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dcd : 48              >            pha         ;use stack to load status
0dce : 28              >            plp
                        
0dcf : 9a                       txs
0dd0 : 08                       php
0dd1 : ad0101                   lda $101
                                cmp_flag 0
0dd4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dd6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd8 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0dd9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ddb : 48              >            pha         ;use stack to load status
0ddc : 28              >            plp
                        
0ddd : 9a                       txs
0dde : 08                       php
0ddf : ad0001                   lda $100
                                cmp_flag $ff
0de2 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0de4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0de6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0de8 : 48              >            pha         ;use stack to load status
0de9 : 28              >            plp
                        
0dea : 9a                       txs
0deb : 08                       php
0dec : ad0001                   lda $100
                                cmp_flag 0
0def : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0df1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df3 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0df4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0df6 : 48              >            pha         ;use stack to load status
0df7 : 28              >            plp
                        
0df8 : 9a                       txs
0df9 : 08                       php
0dfa : adff01                   lda $1ff
                                cmp_flag $ff
0dfd : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e03 : 48              >            pha         ;use stack to load status
0e04 : 28              >            plp
                        
0e05 : 9a                       txs
0e06 : 08                       php
0e07 : adff01                   lda $1ff
                                cmp_flag 0
0e0a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0e0c : a201                     ldx #1
0e0e : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0e0f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e11 : 48              >            pha         ;use stack to load status
0e12 : 28              >            plp
                        
0e13 : ba                       tsx             ;clears Z, N
0e14 : 08                       php             ;sp=00
0e15 : e001                     cpx #1
                                trap_ne
0e17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e19 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0e1c : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e20 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e22 : 48              >            pha         ;use stack to load status
0e23 : 28              >            plp
                        
0e24 : ba                       tsx             ;clears N, sets Z
0e25 : 08                       php             ;sp=ff
0e26 : e000                     cpx #0
                                trap_ne
0e28 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e2a : ad0001                   lda $100
                                cmp_flag $ff-minus
0e2d : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e33 : 48              >            pha         ;use stack to load status
0e34 : 28              >            plp
                        
0e35 : ba                       tsx             ;clears N, sets Z
0e36 : 08                       php             ;sp=fe
0e37 : e0ff                     cpx #$ff
                                trap_ne
0e39 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e3b : adff01                   lda $1ff
                                cmp_flag $ff-zero
0e3e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0e42 : a201                     ldx #1
0e44 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0e45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e47 : 48              >            pha         ;use stack to load status
0e48 : 28              >            plp
                        
0e49 : ba                       tsx             ;clears Z, N
0e4a : 08                       php             ;sp=00
0e4b : e001                     cpx #1
                                trap_ne
0e4d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e4f : ad0101                   lda $101
                                cmp_flag 0
0e52 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e54 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e56 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e58 : 48              >            pha         ;use stack to load status
0e59 : 28              >            plp
                        
0e5a : ba                       tsx             ;clears N, sets Z
0e5b : 08                       php             ;sp=ff
0e5c : e000                     cpx #0
                                trap_ne
0e5e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e60 : ad0001                   lda $100
                                cmp_flag zero
0e63 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e69 : 48              >            pha         ;use stack to load status
0e6a : 28              >            plp
                        
0e6b : ba                       tsx             ;clears N, sets Z
0e6c : 08                       php             ;sp=fe
0e6d : e0ff                     cpx #$ff
                                trap_ne
0e6f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e71 : adff01                   lda $1ff
                                cmp_flag minus
0e74 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e76 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e78 : 68                       pla             ;sp=ff
                                next_test
0e79 : ad0002          >            lda test_case   ;previous test
0e7c : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e80 : a90f            >            lda #test_num   ;*** next tests' number
0e82 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e85 : a003                     ldy #3
0e87 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e87 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e89 : 48              >            pha         ;use stack to load status
0e8a : 28              >            plp
                        
0e8b : b613                     ldx zp1,y
0e8d : 08                       php         ;test stores do not alter flags
0e8e : 8a                       txa
0e8f : 49c3                     eor #$c3
0e91 : 28                       plp
0e92 : 990302                   sta abst,y
0e95 : 08                       php         ;flags after load/store sequence
0e96 : 49c3                     eor #$c3
0e98 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e9d : 68                       pla         ;load status
                                eor_flag 0
0e9e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0ea0 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0ea3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea5 : 88                       dey
0ea6 : 10df                     bpl tldx                  
                        
0ea8 : a003                     ldy #3
0eaa :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0eaa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0eac : 48              >            pha         ;use stack to load status
0ead : 28              >            plp
                        
0eae : b613                     ldx zp1,y
0eb0 : 08                       php         ;test stores do not alter flags
0eb1 : 8a                       txa
0eb2 : 49c3                     eor #$c3
0eb4 : 28                       plp
0eb5 : 990302                   sta abst,y
0eb8 : 08                       php         ;flags after load/store sequence
0eb9 : 49c3                     eor #$c3
0ebb : d91702                   cmp abs1,y  ;test result
                                trap_ne
0ebe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ec1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0ec3 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0ec6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec8 : 88                       dey
0ec9 : 10df                     bpl tldx1                  
                        
0ecb : a003                     ldy #3
0ecd :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0ecd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ecf : 48              >            pha         ;use stack to load status
0ed0 : 28              >            plp
                        
0ed1 : be1702                   ldx abs1,y
0ed4 : 08                       php         ;test stores do not alter flags
0ed5 : 8a                       txa
0ed6 : 49c3                     eor #$c3
0ed8 : aa                       tax
0ed9 : 28                       plp
0eda : 960c                     stx zpt,y
0edc : 08                       php         ;flags after load/store sequence
0edd : 49c3                     eor #$c3
0edf : d91300                   cmp zp1,y   ;test result
                                trap_ne
0ee2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ee4 : 68                       pla         ;load status
                                eor_flag 0
0ee5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0ee7 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0eea : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eec : 88                       dey
0eed : 10de                     bpl tldx2                  
                        
0eef : a003                     ldy #3
0ef1 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0ef1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ef3 : 48              >            pha         ;use stack to load status
0ef4 : 28              >            plp
                        
0ef5 : be1702                   ldx abs1,y
0ef8 : 08                       php         ;test stores do not alter flags
0ef9 : 8a                       txa
0efa : 49c3                     eor #$c3
0efc : aa                       tax
0efd : 28                       plp
0efe : 960c                     stx zpt,y
0f00 : 08                       php         ;flags after load/store sequence
0f01 : 49c3                     eor #$c3
0f03 : d91300                   cmp zp1,y   ;test result
                                trap_ne
0f06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f08 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f09 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0f0b : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0f0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f10 : 88                       dey
0f11 : 10de                     bpl tldx3
                                
0f13 : a003                     ldy #3      ;testing store result
0f15 : a200                     ldx #0
0f17 : b90c00           tstx    lda zpt,y
0f1a : 49c3                     eor #$c3
0f1c : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0f1f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f21 : 960c                     stx zpt,y   ;clear                
0f23 : b90302                   lda abst,y
0f26 : 49c3                     eor #$c3
0f28 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f2b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f2d : 8a                       txa
0f2e : 990302                   sta abst,y  ;clear                
0f31 : 88                       dey
0f32 : 10e3                     bpl tstx
                                next_test
0f34 : ad0002          >            lda test_case   ;previous test
0f37 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0f3b : a910            >            lda #test_num   ;*** next tests' number
0f3d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0f40 : a0fd                     ldy #3+$fa
0f42 : b619             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0f44 : 8a                       txa
0f45 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0f48 : 88                       dey
0f49 : c0fa                     cpy #$fa
0f4b : b0f5                     bcs tldx4                  
0f4d : a0fd                     ldy #3+$fa
0f4f : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0f52 : 9612                     stx zpt-$fa&$ff,y
0f54 : 88                       dey
0f55 : c0fa                     cpy #$fa
0f57 : b0f6                     bcs tldx5                  
0f59 : a003                     ldy #3      ;testing wraparound result
0f5b : a200                     ldx #0
0f5d : b90c00           tstx1   lda zpt,y
0f60 : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0f63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f65 : 960c                     stx zpt,y   ;clear                
0f67 : b90302                   lda abst,y
0f6a : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f6f : 8a                       txa
0f70 : 990302                   sta abst,y  ;clear                
0f73 : 88                       dey
0f74 : 10e7                     bpl tstx1
                                next_test
0f76 : ad0002          >            lda test_case   ;previous test
0f79 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0f7d : a911            >            lda #test_num   ;*** next tests' number
0f7f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f82 : a203                     ldx #3
0f84 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f84 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f86 : 48              >            pha         ;use stack to load status
0f87 : 28              >            plp
                        
0f88 : b413                     ldy zp1,x
0f8a : 08                       php         ;test stores do not alter flags
0f8b : 98                       tya
0f8c : 49c3                     eor #$c3
0f8e : 28                       plp
0f8f : 9d0302                   sta abst,x
0f92 : 08                       php         ;flags after load/store sequence
0f93 : 49c3                     eor #$c3
0f95 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f98 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f9a : 68                       pla         ;load status
                                eor_flag 0
0f9b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f9d : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fa0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa2 : ca                       dex
0fa3 : 10df                     bpl tldy                  
                        
0fa5 : a203                     ldx #3
0fa7 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0fa7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fa9 : 48              >            pha         ;use stack to load status
0faa : 28              >            plp
                        
0fab : b413                     ldy zp1,x
0fad : 08                       php         ;test stores do not alter flags
0fae : 98                       tya
0faf : 49c3                     eor #$c3
0fb1 : 28                       plp
0fb2 : 9d0302                   sta abst,x
0fb5 : 08                       php         ;flags after load/store sequence
0fb6 : 49c3                     eor #$c3
0fb8 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0fbb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fbd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fbe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fc0 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fc3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc5 : ca                       dex
0fc6 : 10df                     bpl tldy1                  
                        
0fc8 : a203                     ldx #3
0fca :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0fca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0fcc : 48              >            pha         ;use stack to load status
0fcd : 28              >            plp
                        
0fce : bc1702                   ldy abs1,x
0fd1 : 08                       php         ;test stores do not alter flags
0fd2 : 98                       tya
0fd3 : 49c3                     eor #$c3
0fd5 : a8                       tay
0fd6 : 28                       plp
0fd7 : 940c                     sty zpt,x
0fd9 : 08                       php         ;flags after load/store sequence
0fda : 49c3                     eor #$c3
0fdc : d513                     cmp zp1,x   ;test result
                                trap_ne
0fde : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe0 : 68                       pla         ;load status
                                eor_flag 0
0fe1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0fe3 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fe6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe8 : ca                       dex
0fe9 : 10df                     bpl tldy2                  
                        
0feb : a203                     ldx #3
0fed :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0fed : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fef : 48              >            pha         ;use stack to load status
0ff0 : 28              >            plp
                        
0ff1 : bc1702                   ldy abs1,x
0ff4 : 08                       php         ;test stores do not alter flags
0ff5 : 98                       tya
0ff6 : 49c3                     eor #$c3
0ff8 : a8                       tay
0ff9 : 28                       plp
0ffa : 940c                     sty zpt,x
0ffc : 08                       php         ;flags after load/store sequence
0ffd : 49c3                     eor #$c3
0fff : d513                     cmp zp1,x   ;test result
                                trap_ne
1001 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1003 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1004 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1006 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1009 : d0fe            >        bne *           ;failed not equal (non zero)
                        
100b : ca                       dex
100c : 10df                     bpl tldy3
                        
100e : a203                     ldx #3      ;testing store result
1010 : a000                     ldy #0
1012 : b50c             tsty    lda zpt,x
1014 : 49c3                     eor #$c3
1016 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1018 : d0fe            >        bne *           ;failed not equal (non zero)
                        
101a : 940c                     sty zpt,x   ;clear                
101c : bd0302                   lda abst,x
101f : 49c3                     eor #$c3
1021 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1024 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1026 : 8a                       txa
1027 : 9d0302                   sta abst,x  ;clear                
102a : ca                       dex
102b : 10e5                     bpl tsty
                                next_test
102d : ad0002          >            lda test_case   ;previous test
1030 : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1032 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
1034 : a912            >            lda #test_num   ;*** next tests' number
1036 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1039 : a2fd                     ldx #3+$fa
103b : b419             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
103d : 98                       tya
103e : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
1041 : ca                       dex
1042 : e0fa                     cpx #$fa
1044 : b0f5                     bcs tldy4                  
1046 : a2fd                     ldx #3+$fa
1048 : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
104b : 9412                     sty zpt-$fa&$ff,x
104d : ca                       dex
104e : e0fa                     cpx #$fa
1050 : b0f6                     bcs tldy5                  
1052 : a203                     ldx #3      ;testing wraparound result
1054 : a000                     ldy #0
1056 : b50c             tsty1   lda zpt,x
1058 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
105a : d0fe            >        bne *           ;failed not equal (non zero)
                        
105c : 940c                     sty zpt,x   ;clear                
105e : bd0302                   lda abst,x
1061 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1064 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1066 : 8a                       txa
1067 : 9d0302                   sta abst,x  ;clear                
106a : ca                       dex
106b : 10e9                     bpl tsty1
                                next_test
106d : ad0002          >            lda test_case   ;previous test
1070 : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1072 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
1074 : a913            >            lda #test_num   ;*** next tests' number
1076 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1079 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
107b : 48              >            pha         ;use stack to load status
107c : 28              >            plp
                        
107d : a613                     ldx zp1
107f : 08                       php         ;test stores do not alter flags
1080 : 8a                       txa
1081 : 49c3                     eor #$c3
1083 : aa                       tax
1084 : 28                       plp
1085 : 8e0302                   stx abst
1088 : 08                       php         ;flags after load/store sequence
1089 : 49c3                     eor #$c3
108b : aa                       tax
108c : e0c3                     cpx #$c3    ;test result
                                trap_ne
108e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1090 : 68                       pla         ;load status
                                eor_flag 0
1091 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1093 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1096 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1098 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
109a : 48              >            pha         ;use stack to load status
109b : 28              >            plp
                        
109c : a614                     ldx zp1+1
109e : 08                       php         ;test stores do not alter flags
109f : 8a                       txa
10a0 : 49c3                     eor #$c3
10a2 : aa                       tax
10a3 : 28                       plp
10a4 : 8e0402                   stx abst+1
10a7 : 08                       php         ;flags after load/store sequence
10a8 : 49c3                     eor #$c3
10aa : aa                       tax
10ab : e082                     cpx #$82    ;test result
                                trap_ne
10ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
10af : 68                       pla         ;load status
                                eor_flag 0
10b0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10b2 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
10b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
10b7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10b9 : 48              >            pha         ;use stack to load status
10ba : 28              >            plp
                        
10bb : a615                     ldx zp1+2
10bd : 08                       php         ;test stores do not alter flags
10be : 8a                       txa
10bf : 49c3                     eor #$c3
10c1 : aa                       tax
10c2 : 28                       plp
10c3 : 8e0502                   stx abst+2
10c6 : 08                       php         ;flags after load/store sequence
10c7 : 49c3                     eor #$c3
10c9 : aa                       tax
10ca : e041                     cpx #$41    ;test result
                                trap_ne
10cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
10ce : 68                       pla         ;load status
                                eor_flag 0
10cf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10d1 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
10d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
10d6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10d8 : 48              >            pha         ;use stack to load status
10d9 : 28              >            plp
                        
10da : a616                     ldx zp1+3
10dc : 08                       php         ;test stores do not alter flags
10dd : 8a                       txa
10de : 49c3                     eor #$c3
10e0 : aa                       tax
10e1 : 28                       plp
10e2 : 8e0602                   stx abst+3
10e5 : 08                       php         ;flags after load/store sequence
10e6 : 49c3                     eor #$c3
10e8 : aa                       tax
10e9 : e000                     cpx #0      ;test result
                                trap_ne
10eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
10ed : 68                       pla         ;load status
                                eor_flag 0
10ee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10f0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
10f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
10f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10f7 : 48              >            pha         ;use stack to load status
10f8 : 28              >            plp
                        
10f9 : a613                     ldx zp1  
10fb : 08                       php         ;test stores do not alter flags
10fc : 8a                       txa
10fd : 49c3                     eor #$c3
10ff : aa                       tax
1100 : 28                       plp
1101 : 8e0302                   stx abst  
1104 : 08                       php         ;flags after load/store sequence
1105 : 49c3                     eor #$c3
1107 : aa                       tax
1108 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
110a : d0fe            >        bne *           ;failed not equal (non zero)
                        
110c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
110d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
110f : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1112 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1114 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1116 : 48              >            pha         ;use stack to load status
1117 : 28              >            plp
                        
1118 : a614                     ldx zp1+1
111a : 08                       php         ;test stores do not alter flags
111b : 8a                       txa
111c : 49c3                     eor #$c3
111e : aa                       tax
111f : 28                       plp
1120 : 8e0402                   stx abst+1
1123 : 08                       php         ;flags after load/store sequence
1124 : 49c3                     eor #$c3
1126 : aa                       tax
1127 : e082                     cpx #$82    ;test result
                                trap_ne
1129 : d0fe            >        bne *           ;failed not equal (non zero)
                        
112b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
112c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
112e : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1131 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1133 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1135 : 48              >            pha         ;use stack to load status
1136 : 28              >            plp
                        
1137 : a615                     ldx zp1+2
1139 : 08                       php         ;test stores do not alter flags
113a : 8a                       txa
113b : 49c3                     eor #$c3
113d : aa                       tax
113e : 28                       plp
113f : 8e0502                   stx abst+2
1142 : 08                       php         ;flags after load/store sequence
1143 : 49c3                     eor #$c3
1145 : aa                       tax
1146 : e041                     cpx #$41    ;test result
                                trap_ne     ;
1148 : d0fe            >        bne *           ;failed not equal (non zero)
                        
114a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
114b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
114d : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1150 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1152 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1154 : 48              >            pha         ;use stack to load status
1155 : 28              >            plp
                        
1156 : a616                     ldx zp1+3
1158 : 08                       php         ;test stores do not alter flags
1159 : 8a                       txa
115a : 49c3                     eor #$c3
115c : aa                       tax
115d : 28                       plp
115e : 8e0602                   stx abst+3
1161 : 08                       php         ;flags after load/store sequence
1162 : 49c3                     eor #$c3
1164 : aa                       tax
1165 : e000                     cpx #0      ;test result
                                trap_ne
1167 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1169 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
116a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
116c : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
116f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
1171 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1173 : 48              >            pha         ;use stack to load status
1174 : 28              >            plp
                        
1175 : ae1702                   ldx abs1  
1178 : 08                       php         ;test stores do not alter flags
1179 : 8a                       txa
117a : 49c3                     eor #$c3
117c : aa                       tax
117d : 28                       plp
117e : 860c                     stx zpt  
1180 : 08                       php         ;flags after load/store sequence
1181 : 49c3                     eor #$c3
1183 : c513                     cmp zp1     ;test result
                                trap_ne
1185 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1187 : 68                       pla         ;load status
                                eor_flag 0
1188 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
118a : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
118d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
118f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1191 : 48              >            pha         ;use stack to load status
1192 : 28              >            plp
                        
1193 : ae1802                   ldx abs1+1
1196 : 08                       php         ;test stores do not alter flags
1197 : 8a                       txa
1198 : 49c3                     eor #$c3
119a : aa                       tax
119b : 28                       plp
119c : 860d                     stx zpt+1
119e : 08                       php         ;flags after load/store sequence
119f : 49c3                     eor #$c3
11a1 : c514                     cmp zp1+1   ;test result
                                trap_ne
11a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11a5 : 68                       pla         ;load status
                                eor_flag 0
11a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11a8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
11ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11af : 48              >            pha         ;use stack to load status
11b0 : 28              >            plp
                        
11b1 : ae1902                   ldx abs1+2
11b4 : 08                       php         ;test stores do not alter flags
11b5 : 8a                       txa
11b6 : 49c3                     eor #$c3
11b8 : aa                       tax
11b9 : 28                       plp
11ba : 860e                     stx zpt+2
11bc : 08                       php         ;flags after load/store sequence
11bd : 49c3                     eor #$c3
11bf : c515                     cmp zp1+2   ;test result
                                trap_ne
11c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11c3 : 68                       pla         ;load status
                                eor_flag 0
11c4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11c6 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
11c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11cb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11cd : 48              >            pha         ;use stack to load status
11ce : 28              >            plp
                        
11cf : ae1a02                   ldx abs1+3
11d2 : 08                       php         ;test stores do not alter flags
11d3 : 8a                       txa
11d4 : 49c3                     eor #$c3
11d6 : aa                       tax
11d7 : 28                       plp
11d8 : 860f                     stx zpt+3
11da : 08                       php         ;flags after load/store sequence
11db : 49c3                     eor #$c3
11dd : c516                     cmp zp1+3   ;test result
                                trap_ne
11df : d0fe            >        bne *           ;failed not equal (non zero)
                        
11e1 : 68                       pla         ;load status
                                eor_flag 0
11e2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11e4 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
11e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
11e9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11eb : 48              >            pha         ;use stack to load status
11ec : 28              >            plp
                        
11ed : ae1702                   ldx abs1  
11f0 : 08                       php         ;test stores do not alter flags
11f1 : 8a                       txa
11f2 : 49c3                     eor #$c3
11f4 : aa                       tax
11f5 : 28                       plp
11f6 : 860c                     stx zpt  
11f8 : 08                       php         ;flags after load/store sequence
11f9 : 49c3                     eor #$c3
11fb : aa                       tax
11fc : e413                     cpx zp1     ;test result
                                trap_ne
11fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1200 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1201 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1203 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1206 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1208 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
120a : 48              >            pha         ;use stack to load status
120b : 28              >            plp
                        
120c : ae1802                   ldx abs1+1
120f : 08                       php         ;test stores do not alter flags
1210 : 8a                       txa
1211 : 49c3                     eor #$c3
1213 : aa                       tax
1214 : 28                       plp
1215 : 860d                     stx zpt+1
1217 : 08                       php         ;flags after load/store sequence
1218 : 49c3                     eor #$c3
121a : aa                       tax
121b : e414                     cpx zp1+1   ;test result
                                trap_ne
121d : d0fe            >        bne *           ;failed not equal (non zero)
                        
121f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1220 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1222 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1225 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1227 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1229 : 48              >            pha         ;use stack to load status
122a : 28              >            plp
                        
122b : ae1902                   ldx abs1+2
122e : 08                       php         ;test stores do not alter flags
122f : 8a                       txa
1230 : 49c3                     eor #$c3
1232 : aa                       tax
1233 : 28                       plp
1234 : 860e                     stx zpt+2
1236 : 08                       php         ;flags after load/store sequence
1237 : 49c3                     eor #$c3
1239 : aa                       tax
123a : e415                     cpx zp1+2   ;test result
                                trap_ne
123c : d0fe            >        bne *           ;failed not equal (non zero)
                        
123e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
123f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1241 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1244 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1246 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1248 : 48              >            pha         ;use stack to load status
1249 : 28              >            plp
                        
124a : ae1a02                   ldx abs1+3
124d : 08                       php         ;test stores do not alter flags
124e : 8a                       txa
124f : 49c3                     eor #$c3
1251 : aa                       tax
1252 : 28                       plp
1253 : 860f                     stx zpt+3
1255 : 08                       php         ;flags after load/store sequence
1256 : 49c3                     eor #$c3
1258 : aa                       tax
1259 : e416                     cpx zp1+3   ;test result
                                trap_ne
125b : d0fe            >        bne *           ;failed not equal (non zero)
                        
125d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
125e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1260 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1263 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
1265 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1267 : 48              >            pha         ;use stack to load status
1268 : 28              >            plp
                        
1269 : a2c3                     ldx #$c3
126b : 08                       php
126c : ec1702                   cpx abs1    ;test result
                                trap_ne
126f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1271 : 68                       pla         ;load status
                                eor_flag 0
1272 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1274 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1277 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1279 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
127b : 48              >            pha         ;use stack to load status
127c : 28              >            plp
                        
127d : a282                     ldx #$82
127f : 08                       php
1280 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
1283 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1285 : 68                       pla         ;load status
                                eor_flag 0
1286 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1288 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
128b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
128d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
128f : 48              >            pha         ;use stack to load status
1290 : 28              >            plp
                        
1291 : a241                     ldx #$41
1293 : 08                       php
1294 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1297 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1299 : 68                       pla         ;load status
                                eor_flag 0
129a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
129c : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
129f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
12a1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
12a3 : 48              >            pha         ;use stack to load status
12a4 : 28              >            plp
                        
12a5 : a200                     ldx #0
12a7 : 08                       php
12a8 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
12ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ad : 68                       pla         ;load status
                                eor_flag 0
12ae : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
12b0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
12b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
12b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12b7 : 48              >            pha         ;use stack to load status
12b8 : 28              >            plp
                        
12b9 : a2c3                     ldx #$c3  
12bb : 08                       php
12bc : ec1702                   cpx abs1    ;test result
                                trap_ne
12bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12c2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12c4 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
12c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12c9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12cb : 48              >            pha         ;use stack to load status
12cc : 28              >            plp
                        
12cd : a282                     ldx #$82
12cf : 08                       php
12d0 : ec1802                   cpx abs1+1  ;test result
                                trap_ne
12d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12d8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
12db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12dd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12df : 48              >            pha         ;use stack to load status
12e0 : 28              >            plp
                        
12e1 : a241                     ldx #$41
12e3 : 08                       php
12e4 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
12e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12ea : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12ec : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
12ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12f1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12f3 : 48              >            pha         ;use stack to load status
12f4 : 28              >            plp
                        
12f5 : a200                     ldx #0
12f7 : 08                       php
12f8 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
12fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12fe : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1300 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1303 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1305 : a200                     ldx #0
1307 : a50c                     lda zpt  
1309 : 49c3                     eor #$c3
130b : c513                     cmp zp1  
                                trap_ne     ;store to zp data
130d : d0fe            >        bne *           ;failed not equal (non zero)
                        
130f : 860c                     stx zpt     ;clear                
1311 : ad0302                   lda abst  
1314 : 49c3                     eor #$c3
1316 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1319 : d0fe            >        bne *           ;failed not equal (non zero)
                        
131b : 8e0302                   stx abst    ;clear                
131e : a50d                     lda zpt+1
1320 : 49c3                     eor #$c3
1322 : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1324 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1326 : 860d                     stx zpt+1   ;clear                
1328 : ad0402                   lda abst+1
132b : 49c3                     eor #$c3
132d : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1330 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1332 : 8e0402                   stx abst+1  ;clear                
1335 : a50e                     lda zpt+2
1337 : 49c3                     eor #$c3
1339 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
133b : d0fe            >        bne *           ;failed not equal (non zero)
                        
133d : 860e                     stx zpt+2   ;clear                
133f : ad0502                   lda abst+2
1342 : 49c3                     eor #$c3
1344 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1347 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1349 : 8e0502                   stx abst+2  ;clear                
134c : a50f                     lda zpt+3
134e : 49c3                     eor #$c3
1350 : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
1352 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1354 : 860f                     stx zpt+3   ;clear                
1356 : ad0602                   lda abst+3
1359 : 49c3                     eor #$c3
135b : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
135e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1360 : 8e0602                   stx abst+3  ;clear                
                                next_test
1363 : ad0002          >            lda test_case   ;previous test
1366 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1368 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
136a : a914            >            lda #test_num   ;*** next tests' number
136c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
136f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1371 : 48              >            pha         ;use stack to load status
1372 : 28              >            plp
                        
1373 : a413                     ldy zp1  
1375 : 08                       php         ;test stores do not alter flags
1376 : 98                       tya
1377 : 49c3                     eor #$c3
1379 : a8                       tay
137a : 28                       plp
137b : 8c0302                   sty abst  
137e : 08                       php         ;flags after load/store sequence
137f : 49c3                     eor #$c3
1381 : a8                       tay
1382 : c0c3                     cpy #$c3    ;test result
                                trap_ne
1384 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1386 : 68                       pla         ;load status
                                eor_flag 0
1387 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1389 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
138c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
138e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1390 : 48              >            pha         ;use stack to load status
1391 : 28              >            plp
                        
1392 : a414                     ldy zp1+1
1394 : 08                       php         ;test stores do not alter flags
1395 : 98                       tya
1396 : 49c3                     eor #$c3
1398 : a8                       tay
1399 : 28                       plp
139a : 8c0402                   sty abst+1
139d : 08                       php         ;flags after load/store sequence
139e : 49c3                     eor #$c3
13a0 : a8                       tay
13a1 : c082                     cpy #$82    ;test result
                                trap_ne
13a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a5 : 68                       pla         ;load status
                                eor_flag 0
13a6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13a8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
13ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
13ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13af : 48              >            pha         ;use stack to load status
13b0 : 28              >            plp
                        
13b1 : a415                     ldy zp1+2
13b3 : 08                       php         ;test stores do not alter flags
13b4 : 98                       tya
13b5 : 49c3                     eor #$c3
13b7 : a8                       tay
13b8 : 28                       plp
13b9 : 8c0502                   sty abst+2
13bc : 08                       php         ;flags after load/store sequence
13bd : 49c3                     eor #$c3
13bf : a8                       tay
13c0 : c041                     cpy #$41    ;test result
                                trap_ne
13c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13c4 : 68                       pla         ;load status
                                eor_flag 0
13c5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13c7 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
13ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
13cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13ce : 48              >            pha         ;use stack to load status
13cf : 28              >            plp
                        
13d0 : a416                     ldy zp1+3
13d2 : 08                       php         ;test stores do not alter flags
13d3 : 98                       tya
13d4 : 49c3                     eor #$c3
13d6 : a8                       tay
13d7 : 28                       plp
13d8 : 8c0602                   sty abst+3
13db : 08                       php         ;flags after load/store sequence
13dc : 49c3                     eor #$c3
13de : a8                       tay
13df : c000                     cpy #0      ;test result
                                trap_ne
13e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13e3 : 68                       pla         ;load status
                                eor_flag 0
13e4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13e6 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
13e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
13eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13ed : 48              >            pha         ;use stack to load status
13ee : 28              >            plp
                        
13ef : a413                     ldy zp1  
13f1 : 08                       php         ;test stores do not alter flags
13f2 : 98                       tya
13f3 : 49c3                     eor #$c3
13f5 : a8                       tay
13f6 : 28                       plp
13f7 : 8c0302                   sty abst  
13fa : 08                       php         ;flags after load/store sequence
13fb : 49c3                     eor #$c3
13fd : a8                       tay
13fe : c0c3                     cpy #$c3    ;test result
                                trap_ne
1400 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1402 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1403 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1405 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1408 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
140a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
140c : 48              >            pha         ;use stack to load status
140d : 28              >            plp
                        
140e : a414                     ldy zp1+1
1410 : 08                       php         ;test stores do not alter flags
1411 : 98                       tya
1412 : 49c3                     eor #$c3
1414 : a8                       tay
1415 : 28                       plp
1416 : 8c0402                   sty abst+1
1419 : 08                       php         ;flags after load/store sequence
141a : 49c3                     eor #$c3
141c : a8                       tay
141d : c082                     cpy #$82   ;test result
                                trap_ne
141f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1421 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1422 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1424 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1427 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1429 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
142b : 48              >            pha         ;use stack to load status
142c : 28              >            plp
                        
142d : a415                     ldy zp1+2
142f : 08                       php         ;test stores do not alter flags
1430 : 98                       tya
1431 : 49c3                     eor #$c3
1433 : a8                       tay
1434 : 28                       plp
1435 : 8c0502                   sty abst+2
1438 : 08                       php         ;flags after load/store sequence
1439 : 49c3                     eor #$c3
143b : a8                       tay
143c : c041                     cpy #$41    ;test result
                                trap_ne
143e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1440 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1441 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1443 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1446 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1448 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
144a : 48              >            pha         ;use stack to load status
144b : 28              >            plp
                        
144c : a416                     ldy zp1+3
144e : 08                       php         ;test stores do not alter flags
144f : 98                       tya
1450 : 49c3                     eor #$c3
1452 : a8                       tay
1453 : 28                       plp
1454 : 8c0602                   sty abst+3
1457 : 08                       php         ;flags after load/store sequence
1458 : 49c3                     eor #$c3
145a : a8                       tay
145b : c000                     cpy #0      ;test result
                                trap_ne
145d : d0fe            >        bne *           ;failed not equal (non zero)
                        
145f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1460 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1462 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1465 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1467 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1469 : 48              >            pha         ;use stack to load status
146a : 28              >            plp
                        
146b : ac1702                   ldy abs1  
146e : 08                       php         ;test stores do not alter flags
146f : 98                       tya
1470 : 49c3                     eor #$c3
1472 : a8                       tay
1473 : 28                       plp
1474 : 840c                     sty zpt  
1476 : 08                       php         ;flags after load/store sequence
1477 : 49c3                     eor #$c3
1479 : a8                       tay
147a : c413                     cpy zp1     ;test result
                                trap_ne
147c : d0fe            >        bne *           ;failed not equal (non zero)
                        
147e : 68                       pla         ;load status
                                eor_flag 0
147f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1481 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1484 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1486 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1488 : 48              >            pha         ;use stack to load status
1489 : 28              >            plp
                        
148a : ac1802                   ldy abs1+1
148d : 08                       php         ;test stores do not alter flags
148e : 98                       tya
148f : 49c3                     eor #$c3
1491 : a8                       tay
1492 : 28                       plp
1493 : 840d                     sty zpt+1
1495 : 08                       php         ;flags after load/store sequence
1496 : 49c3                     eor #$c3
1498 : a8                       tay
1499 : c414                     cpy zp1+1   ;test result
                                trap_ne
149b : d0fe            >        bne *           ;failed not equal (non zero)
                        
149d : 68                       pla         ;load status
                                eor_flag 0
149e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14a0 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
14a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14a7 : 48              >            pha         ;use stack to load status
14a8 : 28              >            plp
                        
14a9 : ac1902                   ldy abs1+2
14ac : 08                       php         ;test stores do not alter flags
14ad : 98                       tya
14ae : 49c3                     eor #$c3
14b0 : a8                       tay
14b1 : 28                       plp
14b2 : 840e                     sty zpt+2
14b4 : 08                       php         ;flags after load/store sequence
14b5 : 49c3                     eor #$c3
14b7 : a8                       tay
14b8 : c415                     cpy zp1+2   ;test result
                                trap_ne
14ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
14bc : 68                       pla         ;load status
                                eor_flag 0
14bd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14bf : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14c4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14c6 : 48              >            pha         ;use stack to load status
14c7 : 28              >            plp
                        
14c8 : ac1a02                   ldy abs1+3
14cb : 08                       php         ;test stores do not alter flags
14cc : 98                       tya
14cd : 49c3                     eor #$c3
14cf : a8                       tay
14d0 : 28                       plp
14d1 : 840f                     sty zpt+3
14d3 : 08                       php         ;flags after load/store sequence
14d4 : 49c3                     eor #$c3
14d6 : a8                       tay
14d7 : c416                     cpy zp1+3   ;test result
                                trap_ne
14d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14db : 68                       pla         ;load status
                                eor_flag 0
14dc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14de : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
14e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
14e3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14e5 : 48              >            pha         ;use stack to load status
14e6 : 28              >            plp
                        
14e7 : ac1702                   ldy abs1  
14ea : 08                       php         ;test stores do not alter flags
14eb : 98                       tya
14ec : 49c3                     eor #$c3
14ee : a8                       tay
14ef : 28                       plp
14f0 : 840c                     sty zpt  
14f2 : 08                       php         ;flags after load/store sequence
14f3 : 49c3                     eor #$c3
14f5 : a8                       tay
14f6 : c513                     cmp zp1     ;test result
                                trap_ne
14f8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14fa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14fb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14fd : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1500 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1502 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1504 : 48              >            pha         ;use stack to load status
1505 : 28              >            plp
                        
1506 : ac1802                   ldy abs1+1
1509 : 08                       php         ;test stores do not alter flags
150a : 98                       tya
150b : 49c3                     eor #$c3
150d : a8                       tay
150e : 28                       plp
150f : 840d                     sty zpt+1
1511 : 08                       php         ;flags after load/store sequence
1512 : 49c3                     eor #$c3
1514 : a8                       tay
1515 : c514                     cmp zp1+1   ;test result
                                trap_ne
1517 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1519 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
151a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
151c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
151f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1521 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1523 : 48              >            pha         ;use stack to load status
1524 : 28              >            plp
                        
1525 : ac1902                   ldy abs1+2
1528 : 08                       php         ;test stores do not alter flags
1529 : 98                       tya
152a : 49c3                     eor #$c3
152c : a8                       tay
152d : 28                       plp
152e : 840e                     sty zpt+2
1530 : 08                       php         ;flags after load/store sequence
1531 : 49c3                     eor #$c3
1533 : a8                       tay
1534 : c515                     cmp zp1+2   ;test result
                                trap_ne
1536 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1538 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1539 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
153b : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
153e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1540 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1542 : 48              >            pha         ;use stack to load status
1543 : 28              >            plp
                        
1544 : ac1a02                   ldy abs1+3
1547 : 08                       php         ;test stores do not alter flags
1548 : 98                       tya
1549 : 49c3                     eor #$c3
154b : a8                       tay
154c : 28                       plp
154d : 840f                     sty zpt+3
154f : 08                       php         ;flags after load/store sequence
1550 : 49c3                     eor #$c3
1552 : a8                       tay
1553 : c516                     cmp zp1+3   ;test result
                                trap_ne
1555 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1557 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1558 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
155a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
155d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
155f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1561 : 48              >            pha         ;use stack to load status
1562 : 28              >            plp
                        
1563 : a0c3                     ldy #$c3  
1565 : 08                       php
1566 : cc1702                   cpy abs1    ;test result
                                trap_ne
1569 : d0fe            >        bne *           ;failed not equal (non zero)
                        
156b : 68                       pla         ;load status
                                eor_flag 0
156c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
156e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1571 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1573 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1575 : 48              >            pha         ;use stack to load status
1576 : 28              >            plp
                        
1577 : a082                     ldy #$82
1579 : 08                       php
157a : cc1802                   cpy abs1+1  ;test result
                                trap_ne
157d : d0fe            >        bne *           ;failed not equal (non zero)
                        
157f : 68                       pla         ;load status
                                eor_flag 0
1580 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1582 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1585 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1587 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1589 : 48              >            pha         ;use stack to load status
158a : 28              >            plp
                        
158b : a041                     ldy #$41
158d : 08                       php
158e : cc1902                   cpy abs1+2  ;test result
                                trap_ne
1591 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1593 : 68                       pla         ;load status
                                eor_flag 0
1594 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1596 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1599 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
159b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
159d : 48              >            pha         ;use stack to load status
159e : 28              >            plp
                        
159f : a000                     ldy #0
15a1 : 08                       php
15a2 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
15a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a7 : 68                       pla         ;load status
                                eor_flag 0
15a8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
15aa : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
15af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15b1 : 48              >            pha         ;use stack to load status
15b2 : 28              >            plp
                        
15b3 : a0c3                     ldy #$c3  
15b5 : 08                       php
15b6 : cc1702                   cpy abs1    ;test result
                                trap_ne
15b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15bb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15bc : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15be : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
15c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15c5 : 48              >            pha         ;use stack to load status
15c6 : 28              >            plp
                        
15c7 : a082                     ldy #$82
15c9 : 08                       php
15ca : cc1802                   cpy abs1+1  ;test result
                                trap_ne
15cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
15cf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15d0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15d2 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
15d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15d7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15d9 : 48              >            pha         ;use stack to load status
15da : 28              >            plp
                        
15db : a041                     ldy #$41
15dd : 08                       php
15de : cc1902                   cpy abs1+2   ;test result
                                trap_ne
15e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15e4 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15e6 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
15e9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15eb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15ed : 48              >            pha         ;use stack to load status
15ee : 28              >            plp
                        
15ef : a000                     ldy #0
15f1 : 08                       php
15f2 : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
15f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15f7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15f8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15fa : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
15ff : a000                     ldy #0
1601 : a50c                     lda zpt  
1603 : 49c3                     eor #$c3
1605 : c513                     cmp zp1  
                                trap_ne     ;store to zp   data
1607 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1609 : 840c                     sty zpt     ;clear                
160b : ad0302                   lda abst  
160e : 49c3                     eor #$c3
1610 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs   data
1613 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1615 : 8c0302                   sty abst    ;clear                
1618 : a50d                     lda zpt+1
161a : 49c3                     eor #$c3
161c : c514                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
161e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1620 : 840d                     sty zpt+1   ;clear                
1622 : ad0402                   lda abst+1
1625 : 49c3                     eor #$c3
1627 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
162a : d0fe            >        bne *           ;failed not equal (non zero)
                        
162c : 8c0402                   sty abst+1  ;clear                
162f : a50e                     lda zpt+2
1631 : 49c3                     eor #$c3
1633 : c515                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
1635 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1637 : 840e                     sty zpt+2   ;clear                
1639 : ad0502                   lda abst+2
163c : 49c3                     eor #$c3
163e : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
1641 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1643 : 8c0502                   sty abst+2  ;clear                
1646 : a50f                     lda zpt+3
1648 : 49c3                     eor #$c3
164a : c516                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
164c : d0fe            >        bne *           ;failed not equal (non zero)
                        
164e : 840f                     sty zpt+3   ;clear                
1650 : ad0602                   lda abst+3
1653 : 49c3                     eor #$c3
1655 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1658 : d0fe            >        bne *           ;failed not equal (non zero)
                        
165a : 8c0602                   sty abst+3  ;clear                
                                next_test
165d : ad0002          >            lda test_case   ;previous test
1660 : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1662 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1664 : a915            >            lda #test_num   ;*** next tests' number
1666 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1669 : a203                     ldx #3
166b :                  tldax    
                                set_stat 0
                       >            load_flag 0
166b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
166d : 48              >            pha         ;use stack to load status
166e : 28              >            plp
                        
166f : b513                     lda zp1,x
1671 : 08                       php         ;test stores do not alter flags
1672 : 49c3                     eor #$c3
1674 : 28                       plp
1675 : 9d0302                   sta abst,x
1678 : 08                       php         ;flags after load/store sequence
1679 : 49c3                     eor #$c3
167b : dd1702                   cmp abs1,x  ;test result
                                trap_ne
167e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1680 : 68                       pla         ;load status
                                eor_flag 0
1681 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1683 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1686 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1688 : ca                       dex
1689 : 10e0                     bpl tldax                  
                        
168b : a203                     ldx #3
168d :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
168d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
168f : 48              >            pha         ;use stack to load status
1690 : 28              >            plp
                        
1691 : b513                     lda zp1,x
1693 : 08                       php         ;test stores do not alter flags
1694 : 49c3                     eor #$c3
1696 : 28                       plp
1697 : 9d0302                   sta abst,x
169a : 08                       php         ;flags after load/store sequence
169b : 49c3                     eor #$c3
169d : dd1702                   cmp abs1,x   ;test result
                                trap_ne
16a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16a3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16a5 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
16a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16aa : ca                       dex
16ab : 10e0                     bpl tldax1                  
                        
16ad : a203                     ldx #3
16af :                  tldax2   
                                set_stat 0
                       >            load_flag 0
16af : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
16b1 : 48              >            pha         ;use stack to load status
16b2 : 28              >            plp
                        
16b3 : bd1702                   lda abs1,x
16b6 : 08                       php         ;test stores do not alter flags
16b7 : 49c3                     eor #$c3
16b9 : 28                       plp
16ba : 950c                     sta zpt,x
16bc : 08                       php         ;flags after load/store sequence
16bd : 49c3                     eor #$c3
16bf : d513                     cmp zp1,x   ;test result
                                trap_ne
16c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16c3 : 68                       pla         ;load status
                                eor_flag 0
16c4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16c6 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
16c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16cb : ca                       dex
16cc : 10e1                     bpl tldax2                  
                        
16ce : a203                     ldx #3
16d0 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
16d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16d2 : 48              >            pha         ;use stack to load status
16d3 : 28              >            plp
                        
16d4 : bd1702                   lda abs1,x
16d7 : 08                       php         ;test stores do not alter flags
16d8 : 49c3                     eor #$c3
16da : 28                       plp
16db : 950c                     sta zpt,x
16dd : 08                       php         ;flags after load/store sequence
16de : 49c3                     eor #$c3
16e0 : d513                     cmp zp1,x   ;test result
                                trap_ne
16e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16e5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16e7 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
16ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
16ec : ca                       dex
16ed : 10e1                     bpl tldax3
                        
16ef : a203                     ldx #3      ;testing store result
16f1 : a000                     ldy #0
16f3 : b50c             tstax   lda zpt,x
16f5 : 49c3                     eor #$c3
16f7 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16fb : 940c                     sty zpt,x   ;clear                
16fd : bd0302                   lda abst,x
1700 : 49c3                     eor #$c3
1702 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1705 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1707 : 8a                       txa
1708 : 9d0302                   sta abst,x  ;clear                
170b : ca                       dex
170c : 10e5                     bpl tstax
                                next_test
170e : ad0002          >            lda test_case   ;previous test
1711 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1713 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
1715 : a916            >            lda #test_num   ;*** next tests' number
1717 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
171a : a003                     ldy #3
171c :                  tlday    
                                set_stat 0
                       >            load_flag 0
171c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
171e : 48              >            pha         ;use stack to load status
171f : 28              >            plp
                        
1720 : b124                     lda (ind1),y
1722 : 08                       php         ;test stores do not alter flags
1723 : 49c3                     eor #$c3
1725 : 28                       plp
1726 : 990302                   sta abst,y
1729 : 08                       php         ;flags after load/store sequence
172a : 49c3                     eor #$c3
172c : d91702                   cmp abs1,y  ;test result
                                trap_ne
172f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1731 : 68                       pla         ;load status
                                eor_flag 0
1732 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1734 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1737 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1739 : 88                       dey
173a : 10e0                     bpl tlday                  
                        
173c : a003                     ldy #3
173e :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
173e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1740 : 48              >            pha         ;use stack to load status
1741 : 28              >            plp
                        
1742 : b124                     lda (ind1),y
1744 : 08                       php         ;test stores do not alter flags
1745 : 49c3                     eor #$c3
1747 : 28                       plp
1748 : 990302                   sta abst,y
174b : 08                       php         ;flags after load/store sequence
174c : 49c3                     eor #$c3
174e : d91702                   cmp abs1,y  ;test result
                                trap_ne
1751 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1753 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1754 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1756 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1759 : d0fe            >        bne *           ;failed not equal (non zero)
                        
175b : 88                       dey
175c : 10e0                     bpl tlday1                  
                        
175e : a003                     ldy #3      ;testing store result
1760 : a200                     ldx #0
1762 : b90302           tstay   lda abst,y
1765 : 49c3                     eor #$c3
1767 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
176a : d0fe            >        bne *           ;failed not equal (non zero)
                        
176c : 8a                       txa
176d : 990302                   sta abst,y  ;clear                
1770 : 88                       dey
1771 : 10ef                     bpl tstay
                        
1773 : a003                     ldy #3
1775 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
1775 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1777 : 48              >            pha         ;use stack to load status
1778 : 28              >            plp
                        
1779 : b91702                   lda abs1,y
177c : 08                       php         ;test stores do not alter flags
177d : 49c3                     eor #$c3
177f : 28                       plp
1780 : 9130                     sta (indt),y
1782 : 08                       php         ;flags after load/store sequence
1783 : 49c3                     eor #$c3
1785 : d124                     cmp (ind1),y    ;test result
                                trap_ne
1787 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1789 : 68                       pla         ;load status
                                eor_flag 0
178a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
178c : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
178f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1791 : 88                       dey
1792 : 10e1                     bpl tlday2                  
                        
1794 : a003                     ldy #3
1796 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1796 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1798 : 48              >            pha         ;use stack to load status
1799 : 28              >            plp
                        
179a : b91702                   lda abs1,y
179d : 08                       php         ;test stores do not alter flags
179e : 49c3                     eor #$c3
17a0 : 28                       plp
17a1 : 9130                     sta (indt),y
17a3 : 08                       php         ;flags after load/store sequence
17a4 : 49c3                     eor #$c3
17a6 : d124                     cmp (ind1),y   ;test result
                                trap_ne
17a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17aa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17ab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17ad : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b2 : 88                       dey
17b3 : 10e1                     bpl tlday3
                                
17b5 : a003                     ldy #3      ;testing store result
17b7 : a200                     ldx #0
17b9 : b90302           tstay1  lda abst,y
17bc : 49c3                     eor #$c3
17be : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
17c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17c3 : 8a                       txa
17c4 : 990302                   sta abst,y  ;clear                
17c7 : 88                       dey
17c8 : 10ef                     bpl tstay1
                                
17ca : a206                     ldx #6
17cc : a003                     ldy #3
17ce :                  tldax4   
                                set_stat 0
                       >            load_flag 0
17ce : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17d0 : 48              >            pha         ;use stack to load status
17d1 : 28              >            plp
                        
17d2 : a124                     lda (ind1,x)
17d4 : 08                       php         ;test stores do not alter flags
17d5 : 49c3                     eor #$c3
17d7 : 28                       plp
17d8 : 8130                     sta (indt,x)
17da : 08                       php         ;flags after load/store sequence
17db : 49c3                     eor #$c3
17dd : d91702                   cmp abs1,y  ;test result
                                trap_ne
17e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17e2 : 68                       pla         ;load status
                                eor_flag 0
17e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17e5 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ea : ca                       dex
17eb : ca                       dex
17ec : 88                       dey
17ed : 10df                     bpl tldax4                  
                        
17ef : a206                     ldx #6
17f1 : a003                     ldy #3
17f3 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
17f3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17f5 : 48              >            pha         ;use stack to load status
17f6 : 28              >            plp
                        
17f7 : a124                     lda (ind1,x)
17f9 : 08                       php         ;test stores do not alter flags
17fa : 49c3                     eor #$c3
17fc : 28                       plp
17fd : 8130                     sta (indt,x)
17ff : 08                       php         ;flags after load/store sequence
1800 : 49c3                     eor #$c3
1802 : d91702                   cmp abs1,y  ;test result
                                trap_ne
1805 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1807 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1808 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
180a : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
180d : d0fe            >        bne *           ;failed not equal (non zero)
                        
180f : ca                       dex
1810 : ca                       dex
1811 : 88                       dey
1812 : 10df                     bpl tldax5
                        
1814 : a003                     ldy #3      ;testing store result
1816 : a200                     ldx #0
1818 : b90302           tstay2  lda abst,y
181b : 49c3                     eor #$c3
181d : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1820 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1822 : 8a                       txa
1823 : 990302                   sta abst,y  ;clear                
1826 : 88                       dey
1827 : 10ef                     bpl tstay2
                                next_test
1829 : ad0002          >            lda test_case   ;previous test
182c : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
182e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
1830 : a917            >            lda #test_num   ;*** next tests' number
1832 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1835 : a2fd                     ldx #3+$fa
1837 : b519             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
1839 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
183c : ca                       dex
183d : e0fa                     cpx #$fa
183f : b0f6                     bcs tldax6                  
1841 : a2fd                     ldx #3+$fa
1843 : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
1846 : 9512                     sta zpt-$fa&$ff,x
1848 : ca                       dex
1849 : e0fa                     cpx #$fa
184b : b0f6                     bcs tldax7
                                                  
184d : a203                     ldx #3      ;testing wraparound result
184f : a000                     ldy #0
1851 : b50c             tstax1  lda zpt,x
1853 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1855 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1857 : 940c                     sty zpt,x   ;clear                
1859 : bd0302                   lda abst,x
185c : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
185f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1861 : 8a                       txa
1862 : 9d0302                   sta abst,x  ;clear                
1865 : ca                       dex
1866 : 10e9                     bpl tstax1
                        
1868 : a0fb                     ldy #3+$f8
186a : a2fe                     ldx #6+$f8
186c : a12c             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
186e : 990b01                   sta abst-$f8,y
1871 : ca                       dex
1872 : ca                       dex
1873 : 88                       dey
1874 : c0f8                     cpy #$f8
1876 : b0f4                     bcs tlday4
1878 : a003                     ldy #3      ;testing wraparound result
187a : a200                     ldx #0
187c : b90302           tstay4  lda abst,y
187f : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1882 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1884 : 8a                       txa
1885 : 990302                   sta abst,y  ;clear                
1888 : 88                       dey
1889 : 10f1                     bpl tstay4
                                
188b : a0fb                     ldy #3+$f8
188d : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1890 : 9138                     sta (inwt),y
1892 : 88                       dey
1893 : c0f8                     cpy #$f8
1895 : b0f6                     bcs tlday5                  
1897 : a003                     ldy #3      ;testing wraparound result
1899 : a200                     ldx #0
189b : b90302           tstay5  lda abst,y
189e : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
18a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18a3 : 8a                       txa
18a4 : 990302                   sta abst,y  ;clear                
18a7 : 88                       dey
18a8 : 10f1                     bpl tstay5
                        
18aa : a0fb                     ldy #3+$f8
18ac : a2fe                     ldx #6+$f8
18ae : b12e             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
18b0 : 8138                     sta (indt-$f8&$ff,x)
18b2 : ca                       dex
18b3 : ca                       dex
18b4 : 88                       dey
18b5 : c0f8                     cpy #$f8
18b7 : b0f5                     bcs tlday6
18b9 : a003                     ldy #3      ;testing wraparound result
18bb : a200                     ldx #0
18bd : b90302           tstay6  lda abst,y
18c0 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
18c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18c5 : 8a                       txa
18c6 : 990302                   sta abst,y  ;clear                
18c9 : 88                       dey
18ca : 10f1                     bpl tstay6
                                next_test
18cc : ad0002          >            lda test_case   ;previous test
18cf : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
18d1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
18d3 : a918            >            lda #test_num   ;*** next tests' number
18d5 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
18d8 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
18da : 48              >            pha         ;use stack to load status
18db : 28              >            plp
                        
18dc : a513                     lda zp1
18de : 08                       php         ;test stores do not alter flags
18df : 49c3                     eor #$c3
18e1 : 28                       plp
18e2 : 8d0302                   sta abst
18e5 : 08                       php         ;flags after load/store sequence
18e6 : 49c3                     eor #$c3
18e8 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
18ec : 68                       pla         ;load status
                                eor_flag 0
18ed : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18ef : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
18f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18f4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18f6 : 48              >            pha         ;use stack to load status
18f7 : 28              >            plp
                        
18f8 : a514                     lda zp1+1
18fa : 08                       php         ;test stores do not alter flags
18fb : 49c3                     eor #$c3
18fd : 28                       plp
18fe : 8d0402                   sta abst+1
1901 : 08                       php         ;flags after load/store sequence
1902 : 49c3                     eor #$c3
1904 : c982                     cmp #$82    ;test result
                                trap_ne
1906 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1908 : 68                       pla         ;load status
                                eor_flag 0
1909 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
190b : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
190e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1910 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1912 : 48              >            pha         ;use stack to load status
1913 : 28              >            plp
                        
1914 : a515                     lda zp1+2
1916 : 08                       php         ;test stores do not alter flags
1917 : 49c3                     eor #$c3
1919 : 28                       plp
191a : 8d0502                   sta abst+2
191d : 08                       php         ;flags after load/store sequence
191e : 49c3                     eor #$c3
1920 : c941                     cmp #$41    ;test result
                                trap_ne
1922 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1924 : 68                       pla         ;load status
                                eor_flag 0
1925 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1927 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
192a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
192c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
192e : 48              >            pha         ;use stack to load status
192f : 28              >            plp
                        
1930 : a516                     lda zp1+3
1932 : 08                       php         ;test stores do not alter flags
1933 : 49c3                     eor #$c3
1935 : 28                       plp
1936 : 8d0602                   sta abst+3
1939 : 08                       php         ;flags after load/store sequence
193a : 49c3                     eor #$c3
193c : c900                     cmp #0      ;test result
                                trap_ne
193e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1940 : 68                       pla         ;load status
                                eor_flag 0
1941 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1943 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1946 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1948 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
194a : 48              >            pha         ;use stack to load status
194b : 28              >            plp
                        
194c : a513                     lda zp1  
194e : 08                       php         ;test stores do not alter flags
194f : 49c3                     eor #$c3
1951 : 28                       plp
1952 : 8d0302                   sta abst  
1955 : 08                       php         ;flags after load/store sequence
1956 : 49c3                     eor #$c3
1958 : c9c3                     cmp #$c3    ;test result
                                trap_ne
195a : d0fe            >        bne *           ;failed not equal (non zero)
                        
195c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
195d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
195f : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1962 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1964 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1966 : 48              >            pha         ;use stack to load status
1967 : 28              >            plp
                        
1968 : a514                     lda zp1+1
196a : 08                       php         ;test stores do not alter flags
196b : 49c3                     eor #$c3
196d : 28                       plp
196e : 8d0402                   sta abst+1
1971 : 08                       php         ;flags after load/store sequence
1972 : 49c3                     eor #$c3
1974 : c982                     cmp #$82    ;test result
                                trap_ne
1976 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1978 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1979 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
197b : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
197e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1980 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1982 : 48              >            pha         ;use stack to load status
1983 : 28              >            plp
                        
1984 : a515                     lda zp1+2
1986 : 08                       php         ;test stores do not alter flags
1987 : 49c3                     eor #$c3
1989 : 28                       plp
198a : 8d0502                   sta abst+2
198d : 08                       php         ;flags after load/store sequence
198e : 49c3                     eor #$c3
1990 : c941                     cmp #$41    ;test result
                                trap_ne
1992 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1994 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1995 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1997 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
199a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
199c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
199e : 48              >            pha         ;use stack to load status
199f : 28              >            plp
                        
19a0 : a516                     lda zp1+3
19a2 : 08                       php         ;test stores do not alter flags
19a3 : 49c3                     eor #$c3
19a5 : 28                       plp
19a6 : 8d0602                   sta abst+3
19a9 : 08                       php         ;flags after load/store sequence
19aa : 49c3                     eor #$c3
19ac : c900                     cmp #0      ;test result
                                trap_ne
19ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19b1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19b3 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19ba : 48              >            pha         ;use stack to load status
19bb : 28              >            plp
                        
19bc : ad1702                   lda abs1  
19bf : 08                       php         ;test stores do not alter flags
19c0 : 49c3                     eor #$c3
19c2 : 28                       plp
19c3 : 850c                     sta zpt  
19c5 : 08                       php         ;flags after load/store sequence
19c6 : 49c3                     eor #$c3
19c8 : c513                     cmp zp1     ;test result
                                trap_ne
19ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
19cc : 68                       pla         ;load status
                                eor_flag 0
19cd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19cf : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
19d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19d4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19d6 : 48              >            pha         ;use stack to load status
19d7 : 28              >            plp
                        
19d8 : ad1802                   lda abs1+1
19db : 08                       php         ;test stores do not alter flags
19dc : 49c3                     eor #$c3
19de : 28                       plp
19df : 850d                     sta zpt+1
19e1 : 08                       php         ;flags after load/store sequence
19e2 : 49c3                     eor #$c3
19e4 : c514                     cmp zp1+1   ;test result
                                trap_ne
19e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19e8 : 68                       pla         ;load status
                                eor_flag 0
19e9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19eb : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
19ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19f2 : 48              >            pha         ;use stack to load status
19f3 : 28              >            plp
                        
19f4 : ad1902                   lda abs1+2
19f7 : 08                       php         ;test stores do not alter flags
19f8 : 49c3                     eor #$c3
19fa : 28                       plp
19fb : 850e                     sta zpt+2
19fd : 08                       php         ;flags after load/store sequence
19fe : 49c3                     eor #$c3
1a00 : c515                     cmp zp1+2   ;test result
                                trap_ne
1a02 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a04 : 68                       pla         ;load status
                                eor_flag 0
1a05 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a07 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a0c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a0e : 48              >            pha         ;use stack to load status
1a0f : 28              >            plp
                        
1a10 : ad1a02                   lda abs1+3
1a13 : 08                       php         ;test stores do not alter flags
1a14 : 49c3                     eor #$c3
1a16 : 28                       plp
1a17 : 850f                     sta zpt+3
1a19 : 08                       php         ;flags after load/store sequence
1a1a : 49c3                     eor #$c3
1a1c : c516                     cmp zp1+3   ;test result
                                trap_ne
1a1e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a20 : 68                       pla         ;load status
                                eor_flag 0
1a21 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a23 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a26 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a28 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a2a : 48              >            pha         ;use stack to load status
1a2b : 28              >            plp
                        
1a2c : ad1702                   lda abs1  
1a2f : 08                       php         ;test stores do not alter flags
1a30 : 49c3                     eor #$c3
1a32 : 28                       plp
1a33 : 850c                     sta zpt  
1a35 : 08                       php         ;flags after load/store sequence
1a36 : 49c3                     eor #$c3
1a38 : c513                     cmp zp1     ;test result
                                trap_ne
1a3a : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a3c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a3d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a3f : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a46 : 48              >            pha         ;use stack to load status
1a47 : 28              >            plp
                        
1a48 : ad1802                   lda abs1+1
1a4b : 08                       php         ;test stores do not alter flags
1a4c : 49c3                     eor #$c3
1a4e : 28                       plp
1a4f : 850d                     sta zpt+1
1a51 : 08                       php         ;flags after load/store sequence
1a52 : 49c3                     eor #$c3
1a54 : c514                     cmp zp1+1   ;test result
                                trap_ne
1a56 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a58 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a59 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a5b : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a5e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a60 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a62 : 48              >            pha         ;use stack to load status
1a63 : 28              >            plp
                        
1a64 : ad1902                   lda abs1+2
1a67 : 08                       php         ;test stores do not alter flags
1a68 : 49c3                     eor #$c3
1a6a : 28                       plp
1a6b : 850e                     sta zpt+2
1a6d : 08                       php         ;flags after load/store sequence
1a6e : 49c3                     eor #$c3
1a70 : c515                     cmp zp1+2   ;test result
                                trap_ne
1a72 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a74 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a75 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a77 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a7a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a7c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a7e : 48              >            pha         ;use stack to load status
1a7f : 28              >            plp
                        
1a80 : ad1a02                   lda abs1+3
1a83 : 08                       php         ;test stores do not alter flags
1a84 : 49c3                     eor #$c3
1a86 : 28                       plp
1a87 : 850f                     sta zpt+3
1a89 : 08                       php         ;flags after load/store sequence
1a8a : 49c3                     eor #$c3
1a8c : c516                     cmp zp1+3   ;test result
                                trap_ne
1a8e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a90 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a91 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a93 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a96 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a98 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1a9a : 48              >            pha         ;use stack to load status
1a9b : 28              >            plp
                        
1a9c : a9c3                     lda #$c3
1a9e : 08                       php
1a9f : cd1702                   cmp abs1    ;test result
                                trap_ne
1aa2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aa4 : 68                       pla         ;load status
                                eor_flag 0
1aa5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1aa7 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1aaa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1aac : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1aae : 48              >            pha         ;use stack to load status
1aaf : 28              >            plp
                        
1ab0 : a982                     lda #$82
1ab2 : 08                       php
1ab3 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1ab6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab8 : 68                       pla         ;load status
                                eor_flag 0
1ab9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1abb : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1abe : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ac0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ac2 : 48              >            pha         ;use stack to load status
1ac3 : 28              >            plp
                        
1ac4 : a941                     lda #$41
1ac6 : 08                       php
1ac7 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1aca : d0fe            >        bne *           ;failed not equal (non zero)
                        
1acc : 68                       pla         ;load status
                                eor_flag 0
1acd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1acf : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1ad2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ad4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ad6 : 48              >            pha         ;use stack to load status
1ad7 : 28              >            plp
                        
1ad8 : a900                     lda #0
1ada : 08                       php
1adb : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1ade : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae0 : 68                       pla         ;load status
                                eor_flag 0
1ae1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1ae3 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1ae6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1ae8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aea : 48              >            pha         ;use stack to load status
1aeb : 28              >            plp
                        
1aec : a9c3                     lda #$c3  
1aee : 08                       php
1aef : cd1702                   cmp abs1    ;test result
                                trap_ne
1af2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1af5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1af7 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1afa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1afc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1afe : 48              >            pha         ;use stack to load status
1aff : 28              >            plp
                        
1b00 : a982                     lda #$82
1b02 : 08                       php
1b03 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1b06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b08 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b09 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b0b : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1b0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b10 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b12 : 48              >            pha         ;use stack to load status
1b13 : 28              >            plp
                        
1b14 : a941                     lda #$41
1b16 : 08                       php
1b17 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1b1a : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b1c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b1d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b1f : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1b22 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b24 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b26 : 48              >            pha         ;use stack to load status
1b27 : 28              >            plp
                        
1b28 : a900                     lda #0
1b2a : 08                       php
1b2b : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1b2e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b30 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b31 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b33 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1b36 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1b38 : a200                     ldx #0
1b3a : a50c                     lda zpt  
1b3c : 49c3                     eor #$c3
1b3e : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1b40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b42 : 860c                     stx zpt     ;clear                
1b44 : ad0302                   lda abst  
1b47 : 49c3                     eor #$c3
1b49 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1b4c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b4e : 8e0302                   stx abst    ;clear                
1b51 : a50d                     lda zpt+1
1b53 : 49c3                     eor #$c3
1b55 : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1b57 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b59 : 860d                     stx zpt+1   ;clear                
1b5b : ad0402                   lda abst+1
1b5e : 49c3                     eor #$c3
1b60 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1b63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b65 : 8e0402                   stx abst+1  ;clear                
1b68 : a50e                     lda zpt+2
1b6a : 49c3                     eor #$c3
1b6c : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1b6e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b70 : 860e                     stx zpt+2   ;clear                
1b72 : ad0502                   lda abst+2
1b75 : 49c3                     eor #$c3
1b77 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1b7a : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b7c : 8e0502                   stx abst+2  ;clear                
1b7f : a50f                     lda zpt+3
1b81 : 49c3                     eor #$c3
1b83 : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
1b85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b87 : 860f                     stx zpt+3   ;clear                
1b89 : ad0602                   lda abst+3
1b8c : 49c3                     eor #$c3
1b8e : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b91 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b93 : 8e0602                   stx abst+3  ;clear                
                                next_test
1b96 : ad0002          >            lda test_case   ;previous test
1b99 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b9d : a919            >            lda #test_num   ;*** next tests' number
1b9f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1ba2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ba4 : 48              >            pha         ;use stack to load status
1ba5 : a9ff            >            lda #$ff     ;precharge accu
1ba7 : 28              >            plp
                        
1ba8 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1baa : 08              >            php         ;save flags
1bab : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1baf : 68              >            pla         ;load status
1bb0 : 48              >            pha
                       >            cmp_flag fz 
1bb1 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bb5 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bb6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bb8 : 48              >            pha         ;use stack to load status
1bb9 : a901            >            lda #1     ;precharge accu
1bbb : 28              >            plp
                        
1bbc : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1bbe : 08              >            php         ;save flags
1bbf : c901            >            cmp #1     ;test result
                       >            trap_ne
1bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc3 : 68              >            pla         ;load status
1bc4 : 48              >            pha
                       >            cmp_flag fv
1bc5 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc9 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bcc : 48              >            pha         ;use stack to load status
1bcd : a901            >            lda #1     ;precharge accu
1bcf : 28              >            plp
                        
1bd0 : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1bd2 : 08              >            php         ;save flags
1bd3 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd7 : 68              >            pla         ;load status
1bd8 : 48              >            pha
                       >            cmp_flag fnz
1bd9 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bdb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bdd : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bde : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1be0 : 48              >            pha         ;use stack to load status
1be1 : a901            >            lda #1     ;precharge accu
1be3 : 28              >            plp
                        
1be4 : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1be6 : 08              >            php         ;save flags
1be7 : c901            >            cmp #1     ;test result
                       >            trap_ne
1be9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1beb : 68              >            pla         ;load status
1bec : 48              >            pha
                       >            cmp_flag fnv
1bed : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bf1 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1bf2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bf4 : 48              >            pha         ;use stack to load status
1bf5 : a9ff            >            lda #$ff     ;precharge accu
1bf7 : 28              >            plp
                        
1bf8 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1bfa : 08              >            php         ;save flags
1bfb : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bff : 68              >            pla         ;load status
1c00 : 48              >            pha
                       >            cmp_flag ~fnv 
1c01 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c05 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c06 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c08 : 48              >            pha         ;use stack to load status
1c09 : a901            >            lda #1     ;precharge accu
1c0b : 28              >            plp
                        
1c0c : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c0e : 08              >            php         ;save flags
1c0f : c901            >            cmp #1     ;test result
                       >            trap_ne
1c11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c13 : 68              >            pla         ;load status
1c14 : 48              >            pha
                       >            cmp_flag ~fnz
1c15 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c19 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c1a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c1c : 48              >            pha         ;use stack to load status
1c1d : a901            >            lda #1     ;precharge accu
1c1f : 28              >            plp
                        
1c20 : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c22 : 08              >            php         ;save flags
1c23 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c27 : 68              >            pla         ;load status
1c28 : 48              >            pha
                       >            cmp_flag ~fv
1c29 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c2d : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c2e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c30 : 48              >            pha         ;use stack to load status
1c31 : a901            >            lda #1     ;precharge accu
1c33 : 28              >            plp
                        
1c34 : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c36 : 08              >            php         ;save flags
1c37 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3b : 68              >            pla         ;load status
1c3c : 48              >            pha
                       >            cmp_flag ~fz
1c3d : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c3f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c41 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1c42 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c44 : 48              >            pha         ;use stack to load status
1c45 : a9ff            >            lda #$ff     ;precharge accu
1c47 : 28              >            plp
                        
1c48 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1c4b : 08              >            php         ;save flags
1c4c : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c50 : 68              >            pla         ;load status
1c51 : 48              >            pha
                       >            cmp_flag fz 
1c52 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c56 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c57 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c59 : 48              >            pha         ;use stack to load status
1c5a : a901            >            lda #1     ;precharge accu
1c5c : 28              >            plp
                        
1c5d : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1c60 : 08              >            php         ;save flags
1c61 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c65 : 68              >            pla         ;load status
1c66 : 48              >            pha
                       >            cmp_flag fv
1c67 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c6b : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c6c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c6e : 48              >            pha         ;use stack to load status
1c6f : a901            >            lda #1     ;precharge accu
1c71 : 28              >            plp
                        
1c72 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1c75 : 08              >            php         ;save flags
1c76 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c7a : 68              >            pla         ;load status
1c7b : 48              >            pha
                       >            cmp_flag fnz
1c7c : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c80 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c81 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c83 : 48              >            pha         ;use stack to load status
1c84 : a901            >            lda #1     ;precharge accu
1c86 : 28              >            plp
                        
1c87 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c8a : 08              >            php         ;save flags
1c8b : c901            >            cmp #1     ;test result
                       >            trap_ne
1c8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c8f : 68              >            pla         ;load status
1c90 : 48              >            pha
                       >            cmp_flag fnv
1c91 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c95 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c96 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c98 : 48              >            pha         ;use stack to load status
1c99 : a9ff            >            lda #$ff     ;precharge accu
1c9b : 28              >            plp
                        
1c9c : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c9f : 08              >            php         ;save flags
1ca0 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ca2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca4 : 68              >            pla         ;load status
1ca5 : 48              >            pha
                       >            cmp_flag ~fnv 
1ca6 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ca8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1caa : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1cab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cad : 48              >            pha         ;use stack to load status
1cae : a901            >            lda #1     ;precharge accu
1cb0 : 28              >            plp
                        
1cb1 : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1cb4 : 08              >            php         ;save flags
1cb5 : c901            >            cmp #1     ;test result
                       >            trap_ne
1cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cb9 : 68              >            pla         ;load status
1cba : 48              >            pha
                       >            cmp_flag ~fnz
1cbb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cbf : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1cc0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cc2 : 48              >            pha         ;use stack to load status
1cc3 : a901            >            lda #1     ;precharge accu
1cc5 : 28              >            plp
                        
1cc6 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1cc9 : 08              >            php         ;save flags
1cca : c901            >            cmp #1     ;test result
                       >            trap_ne
1ccc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cce : 68              >            pla         ;load status
1ccf : 48              >            pha
                       >            cmp_flag ~fv
1cd0 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd4 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1cd5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cd7 : 48              >            pha         ;use stack to load status
1cd8 : a901            >            lda #1     ;precharge accu
1cda : 28              >            plp
                        
1cdb : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1cde : 08              >            php         ;save flags
1cdf : c901            >            cmp #1     ;test result
                       >            trap_ne
1ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce3 : 68              >            pla         ;load status
1ce4 : 48              >            pha
                       >            cmp_flag ~fz
1ce5 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ce7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce9 : 28              >            plp         ;restore status
                        
                                next_test
1cea : ad0002          >            lda test_case   ;previous test
1ced : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1cef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1cf1 : a91a            >            lda #test_num   ;*** next tests' number
1cf3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1cf6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1cf8 : 48              >            pha         ;use stack to load status
1cf9 : a280            >            ldx #$80     ;precharge index x
1cfb : 28              >            plp
                        
1cfc : e417                     cpx zp7f
                                tst_stat fc
1cfe : 08              >            php         ;save status
1cff : 68              >            pla         ;use stack to retrieve status
1d00 : 48              >            pha
                       >            cmp_flag fc
1d01 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d05 : 28              >            plp         ;restore status
                        
1d06 : ca                       dex
1d07 : e417                     cpx zp7f
                                tst_stat fzc
1d09 : 08              >            php         ;save status
1d0a : 68              >            pla         ;use stack to retrieve status
1d0b : 48              >            pha
                       >            cmp_flag fzc
1d0c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d10 : 28              >            plp         ;restore status
                        
1d11 : ca                       dex
1d12 : e417                     cpx zp7f
                                tst_x $7e,fn
1d14 : 08              >            php         ;save flags
1d15 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d19 : 68              >            pla         ;load status
1d1a : 48              >            pha
                       >            cmp_flag fn
1d1b : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1f : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d20 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d22 : 48              >            pha         ;use stack to load status
1d23 : a280            >            ldx #$80     ;precharge index x
1d25 : 28              >            plp
                        
1d26 : e417                     cpx zp7f
                                tst_stat ~fnz
1d28 : 08              >            php         ;save status
1d29 : 68              >            pla         ;use stack to retrieve status
1d2a : 48              >            pha
                       >            cmp_flag ~fnz
1d2b : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d2f : 28              >            plp         ;restore status
                        
1d30 : ca                       dex
1d31 : e417                     cpx zp7f
                                tst_stat ~fn
1d33 : 08              >            php         ;save status
1d34 : 68              >            pla         ;use stack to retrieve status
1d35 : 48              >            pha
                       >            cmp_flag ~fn
1d36 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d3a : 28              >            plp         ;restore status
                        
1d3b : ca                       dex
1d3c : e417                     cpx zp7f
                                tst_x $7e,~fzc
1d3e : 08              >            php         ;save flags
1d3f : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d43 : 68              >            pla         ;load status
1d44 : 48              >            pha
                       >            cmp_flag ~fzc
1d45 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d49 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d4a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d4c : 48              >            pha         ;use stack to load status
1d4d : a280            >            ldx #$80     ;precharge index x
1d4f : 28              >            plp
                        
1d50 : ec1b02                   cpx abs7f
                                tst_stat fc
1d53 : 08              >            php         ;save status
1d54 : 68              >            pla         ;use stack to retrieve status
1d55 : 48              >            pha
                       >            cmp_flag fc
1d56 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5a : 28              >            plp         ;restore status
                        
1d5b : ca                       dex
1d5c : ec1b02                   cpx abs7f
                                tst_stat fzc
1d5f : 08              >            php         ;save status
1d60 : 68              >            pla         ;use stack to retrieve status
1d61 : 48              >            pha
                       >            cmp_flag fzc
1d62 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d66 : 28              >            plp         ;restore status
                        
1d67 : ca                       dex
1d68 : ec1b02                   cpx abs7f
                                tst_x $7e,fn
1d6b : 08              >            php         ;save flags
1d6c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d70 : 68              >            pla         ;load status
1d71 : 48              >            pha
                       >            cmp_flag fn
1d72 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d76 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d77 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d79 : 48              >            pha         ;use stack to load status
1d7a : a280            >            ldx #$80     ;precharge index x
1d7c : 28              >            plp
                        
1d7d : ec1b02                   cpx abs7f
                                tst_stat ~fnz
1d80 : 08              >            php         ;save status
1d81 : 68              >            pla         ;use stack to retrieve status
1d82 : 48              >            pha
                       >            cmp_flag ~fnz
1d83 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d87 : 28              >            plp         ;restore status
                        
1d88 : ca                       dex
1d89 : ec1b02                   cpx abs7f
                                tst_stat ~fn
1d8c : 08              >            php         ;save status
1d8d : 68              >            pla         ;use stack to retrieve status
1d8e : 48              >            pha
                       >            cmp_flag ~fn
1d8f : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d93 : 28              >            plp         ;restore status
                        
1d94 : ca                       dex
1d95 : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
1d98 : 08              >            php         ;save flags
1d99 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d9d : 68              >            pla         ;load status
1d9e : 48              >            pha
                       >            cmp_flag ~fzc
1d9f : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1da1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da3 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1da4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1da6 : 48              >            pha         ;use stack to load status
1da7 : a280            >            ldx #$80     ;precharge index x
1da9 : 28              >            plp
                        
1daa : e07f                     cpx #$7f
                                tst_stat fc
1dac : 08              >            php         ;save status
1dad : 68              >            pla         ;use stack to retrieve status
1dae : 48              >            pha
                       >            cmp_flag fc
1daf : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db3 : 28              >            plp         ;restore status
                        
1db4 : ca                       dex
1db5 : e07f                     cpx #$7f
                                tst_stat fzc
1db7 : 08              >            php         ;save status
1db8 : 68              >            pla         ;use stack to retrieve status
1db9 : 48              >            pha
                       >            cmp_flag fzc
1dba : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dbe : 28              >            plp         ;restore status
                        
1dbf : ca                       dex
1dc0 : e07f                     cpx #$7f
                                tst_x $7e,fn
1dc2 : 08              >            php         ;save flags
1dc3 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1dc5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc7 : 68              >            pla         ;load status
1dc8 : 48              >            pha
                       >            cmp_flag fn
1dc9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dcd : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1dce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1dd0 : 48              >            pha         ;use stack to load status
1dd1 : a280            >            ldx #$80     ;precharge index x
1dd3 : 28              >            plp
                        
1dd4 : e07f                     cpx #$7f
                                tst_stat ~fnz
1dd6 : 08              >            php         ;save status
1dd7 : 68              >            pla         ;use stack to retrieve status
1dd8 : 48              >            pha
                       >            cmp_flag ~fnz
1dd9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ddb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ddd : 28              >            plp         ;restore status
                        
1dde : ca                       dex
1ddf : e07f                     cpx #$7f
                                tst_stat ~fn
1de1 : 08              >            php         ;save status
1de2 : 68              >            pla         ;use stack to retrieve status
1de3 : 48              >            pha
                       >            cmp_flag ~fn
1de4 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de8 : 28              >            plp         ;restore status
                        
1de9 : ca                       dex
1dea : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1dec : 08              >            php         ;save flags
1ded : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1def : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df1 : 68              >            pla         ;load status
1df2 : 48              >            pha
                       >            cmp_flag ~fzc
1df3 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1df5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df7 : 28              >            plp         ;restore status
                        
                                next_test
1df8 : ad0002          >            lda test_case   ;previous test
1dfb : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1dfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1dff : a91b            >            lda #test_num   ;*** next tests' number
1e01 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1e04 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e06 : 48              >            pha         ;use stack to load status
1e07 : a080            >            ldy #$80     ;precharge index y
1e09 : 28              >            plp
                        
1e0a : c417                     cpy zp7f
                                tst_stat fc
1e0c : 08              >            php         ;save status
1e0d : 68              >            pla         ;use stack to retrieve status
1e0e : 48              >            pha
                       >            cmp_flag fc
1e0f : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e13 : 28              >            plp         ;restore status
                        
1e14 : 88                       dey
1e15 : c417                     cpy zp7f
                                tst_stat fzc
1e17 : 08              >            php         ;save status
1e18 : 68              >            pla         ;use stack to retrieve status
1e19 : 48              >            pha
                       >            cmp_flag fzc
1e1a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1e : 28              >            plp         ;restore status
                        
1e1f : 88                       dey
1e20 : c417                     cpy zp7f
                                tst_y $7e,fn
1e22 : 08              >            php         ;save flags
1e23 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e27 : 68              >            pla         ;load status
1e28 : 48              >            pha
                       >            cmp_flag fn
1e29 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2d : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e2e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e30 : 48              >            pha         ;use stack to load status
1e31 : a080            >            ldy #$80     ;precharge index y
1e33 : 28              >            plp
                        
1e34 : c417                     cpy zp7f
                                tst_stat ~fnz
1e36 : 08              >            php         ;save status
1e37 : 68              >            pla         ;use stack to retrieve status
1e38 : 48              >            pha
                       >            cmp_flag ~fnz
1e39 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3d : 28              >            plp         ;restore status
                        
1e3e : 88                       dey
1e3f : c417                     cpy zp7f
                                tst_stat ~fn
1e41 : 08              >            php         ;save status
1e42 : 68              >            pla         ;use stack to retrieve status
1e43 : 48              >            pha
                       >            cmp_flag ~fn
1e44 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e48 : 28              >            plp         ;restore status
                        
1e49 : 88                       dey
1e4a : c417                     cpy zp7f
                                tst_y $7e,~fzc
1e4c : 08              >            php         ;save flags
1e4d : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e51 : 68              >            pla         ;load status
1e52 : 48              >            pha
                       >            cmp_flag ~fzc
1e53 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e57 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e58 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e5a : 48              >            pha         ;use stack to load status
1e5b : a080            >            ldy #$80     ;precharge index y
1e5d : 28              >            plp
                        
1e5e : cc1b02                   cpy abs7f
                                tst_stat fc
1e61 : 08              >            php         ;save status
1e62 : 68              >            pla         ;use stack to retrieve status
1e63 : 48              >            pha
                       >            cmp_flag fc
1e64 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e68 : 28              >            plp         ;restore status
                        
1e69 : 88                       dey
1e6a : cc1b02                   cpy abs7f
                                tst_stat fzc
1e6d : 08              >            php         ;save status
1e6e : 68              >            pla         ;use stack to retrieve status
1e6f : 48              >            pha
                       >            cmp_flag fzc
1e70 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e74 : 28              >            plp         ;restore status
                        
1e75 : 88                       dey
1e76 : cc1b02                   cpy abs7f
                                tst_y $7e,fn
1e79 : 08              >            php         ;save flags
1e7a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7e : 68              >            pla         ;load status
1e7f : 48              >            pha
                       >            cmp_flag fn
1e80 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e84 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e85 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e87 : 48              >            pha         ;use stack to load status
1e88 : a080            >            ldy #$80     ;precharge index y
1e8a : 28              >            plp
                        
1e8b : cc1b02                   cpy abs7f
                                tst_stat ~fnz
1e8e : 08              >            php         ;save status
1e8f : 68              >            pla         ;use stack to retrieve status
1e90 : 48              >            pha
                       >            cmp_flag ~fnz
1e91 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e95 : 28              >            plp         ;restore status
                        
1e96 : 88                       dey
1e97 : cc1b02                   cpy abs7f
                                tst_stat ~fn
1e9a : 08              >            php         ;save status
1e9b : 68              >            pla         ;use stack to retrieve status
1e9c : 48              >            pha
                       >            cmp_flag ~fn
1e9d : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea1 : 28              >            plp         ;restore status
                        
1ea2 : 88                       dey
1ea3 : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
1ea6 : 08              >            php         ;save flags
1ea7 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ea9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eab : 68              >            pla         ;load status
1eac : 48              >            pha
                       >            cmp_flag ~fzc
1ead : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eaf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb1 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1eb2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1eb4 : 48              >            pha         ;use stack to load status
1eb5 : a080            >            ldy #$80     ;precharge index y
1eb7 : 28              >            plp
                        
1eb8 : c07f                     cpy #$7f
                                tst_stat fc
1eba : 08              >            php         ;save status
1ebb : 68              >            pla         ;use stack to retrieve status
1ebc : 48              >            pha
                       >            cmp_flag fc
1ebd : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ebf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec1 : 28              >            plp         ;restore status
                        
1ec2 : 88                       dey
1ec3 : c07f                     cpy #$7f
                                tst_stat fzc
1ec5 : 08              >            php         ;save status
1ec6 : 68              >            pla         ;use stack to retrieve status
1ec7 : 48              >            pha
                       >            cmp_flag fzc
1ec8 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ecc : 28              >            plp         ;restore status
                        
1ecd : 88                       dey
1ece : c07f                     cpy #$7f
                                tst_y $7e,fn
1ed0 : 08              >            php         ;save flags
1ed1 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ed3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ed5 : 68              >            pla         ;load status
1ed6 : 48              >            pha
                       >            cmp_flag fn
1ed7 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ed9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edb : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1edc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ede : 48              >            pha         ;use stack to load status
1edf : a080            >            ldy #$80     ;precharge index y
1ee1 : 28              >            plp
                        
1ee2 : c07f                     cpy #$7f
                                tst_stat ~fnz
1ee4 : 08              >            php         ;save status
1ee5 : 68              >            pla         ;use stack to retrieve status
1ee6 : 48              >            pha
                       >            cmp_flag ~fnz
1ee7 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ee9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eeb : 28              >            plp         ;restore status
                        
1eec : 88                       dey
1eed : c07f                     cpy #$7f
                                tst_stat ~fn
1eef : 08              >            php         ;save status
1ef0 : 68              >            pla         ;use stack to retrieve status
1ef1 : 48              >            pha
                       >            cmp_flag ~fn
1ef2 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef6 : 28              >            plp         ;restore status
                        
1ef7 : 88                       dey
1ef8 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1efa : 08              >            php         ;save flags
1efb : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1efd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eff : 68              >            pla         ;load status
1f00 : 48              >            pha
                       >            cmp_flag ~fzc
1f01 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f05 : 28              >            plp         ;restore status
                        
                                next_test
1f06 : ad0002          >            lda test_case   ;previous test
1f09 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1f0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1f0d : a91c            >            lda #test_num   ;*** next tests' number
1f0f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1f12 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f14 : 48              >            pha         ;use stack to load status
1f15 : a980            >            lda #$80     ;precharge accu
1f17 : 28              >            plp
                        
1f18 : c517                     cmp zp7f
                                tst_a $80,fc
1f1a : 08              >            php         ;save flags
1f1b : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1f : 68              >            pla         ;load status
1f20 : 48              >            pha
                       >            cmp_flag fc
1f21 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f25 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f26 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f28 : 48              >            pha         ;use stack to load status
1f29 : a97f            >            lda #$7f     ;precharge accu
1f2b : 28              >            plp
                        
1f2c : c517                     cmp zp7f
                                tst_a $7f,fzc
1f2e : 08              >            php         ;save flags
1f2f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f33 : 68              >            pla         ;load status
1f34 : 48              >            pha
                       >            cmp_flag fzc
1f35 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f39 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f3a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f3c : 48              >            pha         ;use stack to load status
1f3d : a97e            >            lda #$7e     ;precharge accu
1f3f : 28              >            plp
                        
1f40 : c517                     cmp zp7f
                                tst_a $7e,fn
1f42 : 08              >            php         ;save flags
1f43 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f47 : 68              >            pla         ;load status
1f48 : 48              >            pha
                       >            cmp_flag fn
1f49 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f4d : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f4e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f50 : 48              >            pha         ;use stack to load status
1f51 : a980            >            lda #$80     ;precharge accu
1f53 : 28              >            plp
                        
1f54 : c517                     cmp zp7f
                                tst_a $80,~fnz
1f56 : 08              >            php         ;save flags
1f57 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5b : 68              >            pla         ;load status
1f5c : 48              >            pha
                       >            cmp_flag ~fnz
1f5d : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f61 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f62 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f64 : 48              >            pha         ;use stack to load status
1f65 : a97f            >            lda #$7f     ;precharge accu
1f67 : 28              >            plp
                        
1f68 : c517                     cmp zp7f
                                tst_a $7f,~fn
1f6a : 08              >            php         ;save flags
1f6b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6f : 68              >            pla         ;load status
1f70 : 48              >            pha
                       >            cmp_flag ~fn
1f71 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f75 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f76 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f78 : 48              >            pha         ;use stack to load status
1f79 : a97e            >            lda #$7e     ;precharge accu
1f7b : 28              >            plp
                        
1f7c : c517                     cmp zp7f
                                tst_a $7e,~fzc
1f7e : 08              >            php         ;save flags
1f7f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f83 : 68              >            pla         ;load status
1f84 : 48              >            pha
                       >            cmp_flag ~fzc
1f85 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f89 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f8a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f8c : 48              >            pha         ;use stack to load status
1f8d : a980            >            lda #$80     ;precharge accu
1f8f : 28              >            plp
                        
1f90 : cd1b02                   cmp abs7f
                                tst_a $80,fc
1f93 : 08              >            php         ;save flags
1f94 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f98 : 68              >            pla         ;load status
1f99 : 48              >            pha
                       >            cmp_flag fc
1f9a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fa1 : 48              >            pha         ;use stack to load status
1fa2 : a97f            >            lda #$7f     ;precharge accu
1fa4 : 28              >            plp
                        
1fa5 : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
1fa8 : 08              >            php         ;save flags
1fa9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fad : 68              >            pla         ;load status
1fae : 48              >            pha
                       >            cmp_flag fzc
1faf : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fb4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fb6 : 48              >            pha         ;use stack to load status
1fb7 : a97e            >            lda #$7e     ;precharge accu
1fb9 : 28              >            plp
                        
1fba : cd1b02                   cmp abs7f
                                tst_a $7e,fn
1fbd : 08              >            php         ;save flags
1fbe : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc2 : 68              >            pla         ;load status
1fc3 : 48              >            pha
                       >            cmp_flag fn
1fc4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc8 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fc9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fcb : 48              >            pha         ;use stack to load status
1fcc : a980            >            lda #$80     ;precharge accu
1fce : 28              >            plp
                        
1fcf : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
1fd2 : 08              >            php         ;save flags
1fd3 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd7 : 68              >            pla         ;load status
1fd8 : 48              >            pha
                       >            cmp_flag ~fnz
1fd9 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fdb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fdd : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fde : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fe0 : 48              >            pha         ;use stack to load status
1fe1 : a97f            >            lda #$7f     ;precharge accu
1fe3 : 28              >            plp
                        
1fe4 : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
1fe7 : 08              >            php         ;save flags
1fe8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fec : 68              >            pla         ;load status
1fed : 48              >            pha
                       >            cmp_flag ~fn
1fee : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ff0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1ff3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ff5 : 48              >            pha         ;use stack to load status
1ff6 : a97e            >            lda #$7e     ;precharge accu
1ff8 : 28              >            plp
                        
1ff9 : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
1ffc : 08              >            php         ;save flags
1ffd : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2001 : 68              >            pla         ;load status
2002 : 48              >            pha
                       >            cmp_flag ~fzc
2003 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2005 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2007 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2008 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
200a : 48              >            pha         ;use stack to load status
200b : a980            >            lda #$80     ;precharge accu
200d : 28              >            plp
                        
200e : c97f                     cmp #$7f
                                tst_a $80,fc
2010 : 08              >            php         ;save flags
2011 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2013 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2015 : 68              >            pla         ;load status
2016 : 48              >            pha
                       >            cmp_flag fc
2017 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2019 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
201b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
201c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
201e : 48              >            pha         ;use stack to load status
201f : a97f            >            lda #$7f     ;precharge accu
2021 : 28              >            plp
                        
2022 : c97f                     cmp #$7f
                                tst_a $7f,fzc
2024 : 08              >            php         ;save flags
2025 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2027 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2029 : 68              >            pla         ;load status
202a : 48              >            pha
                       >            cmp_flag fzc
202b : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
202d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
202f : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2030 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2032 : 48              >            pha         ;use stack to load status
2033 : a97e            >            lda #$7e     ;precharge accu
2035 : 28              >            plp
                        
2036 : c97f                     cmp #$7f
                                tst_a $7e,fn
2038 : 08              >            php         ;save flags
2039 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
203b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203d : 68              >            pla         ;load status
203e : 48              >            pha
                       >            cmp_flag fn
203f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2041 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2043 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2044 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2046 : 48              >            pha         ;use stack to load status
2047 : a980            >            lda #$80     ;precharge accu
2049 : 28              >            plp
                        
204a : c97f                     cmp #$7f
                                tst_a $80,~fnz
204c : 08              >            php         ;save flags
204d : c980            >            cmp #$80     ;test result
                       >            trap_ne
204f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2051 : 68              >            pla         ;load status
2052 : 48              >            pha
                       >            cmp_flag ~fnz
2053 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2055 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2057 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2058 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
205a : 48              >            pha         ;use stack to load status
205b : a97f            >            lda #$7f     ;precharge accu
205d : 28              >            plp
                        
205e : c97f                     cmp #$7f
                                tst_a $7f,~fn
2060 : 08              >            php         ;save flags
2061 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2063 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2065 : 68              >            pla         ;load status
2066 : 48              >            pha
                       >            cmp_flag ~fn
2067 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2069 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
206b : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
206c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
206e : 48              >            pha         ;use stack to load status
206f : a97e            >            lda #$7e     ;precharge accu
2071 : 28              >            plp
                        
2072 : c97f                     cmp #$7f
                                tst_a $7e,~fzc
2074 : 08              >            php         ;save flags
2075 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2077 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2079 : 68              >            pla         ;load status
207a : 48              >            pha
                       >            cmp_flag ~fzc
207b : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
207d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207f : 28              >            plp         ;restore status
                        
                        
2080 : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
2082 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2084 : 48              >            pha         ;use stack to load status
2085 : a980            >            lda #$80     ;precharge accu
2087 : 28              >            plp
                        
2088 : d513                     cmp zp1,x
                                tst_a $80,fc
208a : 08              >            php         ;save flags
208b : c980            >            cmp #$80     ;test result
                       >            trap_ne
208d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208f : 68              >            pla         ;load status
2090 : 48              >            pha
                       >            cmp_flag fc
2091 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2093 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2095 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2096 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2098 : 48              >            pha         ;use stack to load status
2099 : a97f            >            lda #$7f     ;precharge accu
209b : 28              >            plp
                        
209c : d513                     cmp zp1,x
                                tst_a $7f,fzc
209e : 08              >            php         ;save flags
209f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a3 : 68              >            pla         ;load status
20a4 : 48              >            pha
                       >            cmp_flag fzc
20a5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a9 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20aa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20ac : 48              >            pha         ;use stack to load status
20ad : a97e            >            lda #$7e     ;precharge accu
20af : 28              >            plp
                        
20b0 : d513                     cmp zp1,x
                                tst_a $7e,fn
20b2 : 08              >            php         ;save flags
20b3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b7 : 68              >            pla         ;load status
20b8 : 48              >            pha
                       >            cmp_flag fn
20b9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20bb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20bd : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20be : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20c0 : 48              >            pha         ;use stack to load status
20c1 : a980            >            lda #$80     ;precharge accu
20c3 : 28              >            plp
                        
20c4 : d513                     cmp zp1,x
                                tst_a $80,~fnz
20c6 : 08              >            php         ;save flags
20c7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20cb : 68              >            pla         ;load status
20cc : 48              >            pha
                       >            cmp_flag ~fnz
20cd : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20d4 : 48              >            pha         ;use stack to load status
20d5 : a97f            >            lda #$7f     ;precharge accu
20d7 : 28              >            plp
                        
20d8 : d513                     cmp zp1,x
                                tst_a $7f,~fn
20da : 08              >            php         ;save flags
20db : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20df : 68              >            pla         ;load status
20e0 : 48              >            pha
                       >            cmp_flag ~fn
20e1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e5 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20e6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20e8 : 48              >            pha         ;use stack to load status
20e9 : a97e            >            lda #$7e     ;precharge accu
20eb : 28              >            plp
                        
20ec : d513                     cmp zp1,x
                                tst_a $7e,~fzc
20ee : 08              >            php         ;save flags
20ef : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f3 : 68              >            pla         ;load status
20f4 : 48              >            pha
                       >            cmp_flag ~fzc
20f5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20fa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20fc : 48              >            pha         ;use stack to load status
20fd : a980            >            lda #$80     ;precharge accu
20ff : 28              >            plp
                        
2100 : dd1702                   cmp abs1,x
                                tst_a $80,fc
2103 : 08              >            php         ;save flags
2104 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2106 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2108 : 68              >            pla         ;load status
2109 : 48              >            pha
                       >            cmp_flag fc
210a : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
210c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210e : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
210f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2111 : 48              >            pha         ;use stack to load status
2112 : a97f            >            lda #$7f     ;precharge accu
2114 : 28              >            plp
                        
2115 : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
2118 : 08              >            php         ;save flags
2119 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
211b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211d : 68              >            pla         ;load status
211e : 48              >            pha
                       >            cmp_flag fzc
211f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2121 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2123 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2124 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2126 : 48              >            pha         ;use stack to load status
2127 : a97e            >            lda #$7e     ;precharge accu
2129 : 28              >            plp
                        
212a : dd1702                   cmp abs1,x
                                tst_a $7e,fn
212d : 08              >            php         ;save flags
212e : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2130 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2132 : 68              >            pla         ;load status
2133 : 48              >            pha
                       >            cmp_flag fn
2134 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2136 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2138 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2139 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
213b : 48              >            pha         ;use stack to load status
213c : a980            >            lda #$80     ;precharge accu
213e : 28              >            plp
                        
213f : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
2142 : 08              >            php         ;save flags
2143 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2145 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2147 : 68              >            pla         ;load status
2148 : 48              >            pha
                       >            cmp_flag ~fnz
2149 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
214b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214d : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
214e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2150 : 48              >            pha         ;use stack to load status
2151 : a97f            >            lda #$7f     ;precharge accu
2153 : 28              >            plp
                        
2154 : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
2157 : 08              >            php         ;save flags
2158 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
215a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215c : 68              >            pla         ;load status
215d : 48              >            pha
                       >            cmp_flag ~fn
215e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2160 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2162 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2163 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2165 : 48              >            pha         ;use stack to load status
2166 : a97e            >            lda #$7e     ;precharge accu
2168 : 28              >            plp
                        
2169 : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
216c : 08              >            php         ;save flags
216d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
216f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2171 : 68              >            pla         ;load status
2172 : 48              >            pha
                       >            cmp_flag ~fzc
2173 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2175 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2177 : 28              >            plp         ;restore status
                        
                        
2178 : a004                     ldy #4          ;with indexing by Y
217a : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
217c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
217e : 48              >            pha         ;use stack to load status
217f : a980            >            lda #$80     ;precharge accu
2181 : 28              >            plp
                        
2182 : d91702                   cmp abs1,y
                                tst_a $80,fc
2185 : 08              >            php         ;save flags
2186 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2188 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218a : 68              >            pla         ;load status
218b : 48              >            pha
                       >            cmp_flag fc
218c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
218e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2190 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2191 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2193 : 48              >            pha         ;use stack to load status
2194 : a97f            >            lda #$7f     ;precharge accu
2196 : 28              >            plp
                        
2197 : d91702                   cmp abs1,y
                                tst_a $7f,fzc
219a : 08              >            php         ;save flags
219b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
219d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219f : 68              >            pla         ;load status
21a0 : 48              >            pha
                       >            cmp_flag fzc
21a1 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a5 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21a6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21a8 : 48              >            pha         ;use stack to load status
21a9 : a97e            >            lda #$7e     ;precharge accu
21ab : 28              >            plp
                        
21ac : d91702                   cmp abs1,y
                                tst_a $7e,fn
21af : 08              >            php         ;save flags
21b0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b4 : 68              >            pla         ;load status
21b5 : 48              >            pha
                       >            cmp_flag fn
21b6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ba : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21bd : 48              >            pha         ;use stack to load status
21be : a980            >            lda #$80     ;precharge accu
21c0 : 28              >            plp
                        
21c1 : d91702                   cmp abs1,y
                                tst_a $80,~fnz
21c4 : 08              >            php         ;save flags
21c5 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c9 : 68              >            pla         ;load status
21ca : 48              >            pha
                       >            cmp_flag ~fnz
21cb : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21cf : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21d2 : 48              >            pha         ;use stack to load status
21d3 : a97f            >            lda #$7f     ;precharge accu
21d5 : 28              >            plp
                        
21d6 : d91702                   cmp abs1,y
                                tst_a $7f,~fn
21d9 : 08              >            php         ;save flags
21da : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21de : 68              >            pla         ;load status
21df : 48              >            pha
                       >            cmp_flag ~fn
21e0 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e4 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21e5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21e7 : 48              >            pha         ;use stack to load status
21e8 : a97e            >            lda #$7e     ;precharge accu
21ea : 28              >            plp
                        
21eb : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
21ee : 08              >            php         ;save flags
21ef : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f3 : 68              >            pla         ;load status
21f4 : 48              >            pha
                       >            cmp_flag ~fzc
21f5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f9 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21fa : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21fc : 48              >            pha         ;use stack to load status
21fd : a980            >            lda #$80     ;precharge accu
21ff : 28              >            plp
                        
2200 : c124                     cmp (ind1,x)
                                tst_a $80,fc
2202 : 08              >            php         ;save flags
2203 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2205 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2207 : 68              >            pla         ;load status
2208 : 48              >            pha
                       >            cmp_flag fc
2209 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
220b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
220d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
220e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2210 : 48              >            pha         ;use stack to load status
2211 : a97f            >            lda #$7f     ;precharge accu
2213 : 28              >            plp
                        
2214 : c124                     cmp (ind1,x)
                                tst_a $7f,fzc
2216 : 08              >            php         ;save flags
2217 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2219 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221b : 68              >            pla         ;load status
221c : 48              >            pha
                       >            cmp_flag fzc
221d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
221f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2221 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2222 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2224 : 48              >            pha         ;use stack to load status
2225 : a97e            >            lda #$7e     ;precharge accu
2227 : 28              >            plp
                        
2228 : c124                     cmp (ind1,x)
                                tst_a $7e,fn
222a : 08              >            php         ;save flags
222b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
222d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222f : 68              >            pla         ;load status
2230 : 48              >            pha
                       >            cmp_flag fn
2231 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2233 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2235 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2236 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2238 : 48              >            pha         ;use stack to load status
2239 : a980            >            lda #$80     ;precharge accu
223b : 28              >            plp
                        
223c : c124                     cmp (ind1,x)
                                tst_a $80,~fnz
223e : 08              >            php         ;save flags
223f : c980            >            cmp #$80     ;test result
                       >            trap_ne
2241 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2243 : 68              >            pla         ;load status
2244 : 48              >            pha
                       >            cmp_flag ~fnz
2245 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2247 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2249 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
224a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
224c : 48              >            pha         ;use stack to load status
224d : a97f            >            lda #$7f     ;precharge accu
224f : 28              >            plp
                        
2250 : c124                     cmp (ind1,x)
                                tst_a $7f,~fn
2252 : 08              >            php         ;save flags
2253 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2255 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2257 : 68              >            pla         ;load status
2258 : 48              >            pha
                       >            cmp_flag ~fn
2259 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
225b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
225d : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
225e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2260 : 48              >            pha         ;use stack to load status
2261 : a97e            >            lda #$7e     ;precharge accu
2263 : 28              >            plp
                        
2264 : c124                     cmp (ind1,x)
                                tst_a $7e,~fzc
2266 : 08              >            php         ;save flags
2267 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2269 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226b : 68              >            pla         ;load status
226c : 48              >            pha
                       >            cmp_flag ~fzc
226d : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
226f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2271 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
2272 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2274 : 48              >            pha         ;use stack to load status
2275 : a980            >            lda #$80     ;precharge accu
2277 : 28              >            plp
                        
2278 : d124                     cmp (ind1),y
                                tst_a $80,fc
227a : 08              >            php         ;save flags
227b : c980            >            cmp #$80     ;test result
                       >            trap_ne
227d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227f : 68              >            pla         ;load status
2280 : 48              >            pha
                       >            cmp_flag fc
2281 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2283 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2285 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2286 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2288 : 48              >            pha         ;use stack to load status
2289 : a97f            >            lda #$7f     ;precharge accu
228b : 28              >            plp
                        
228c : d124                     cmp (ind1),y
                                tst_a $7f,fzc
228e : 08              >            php         ;save flags
228f : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2291 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2293 : 68              >            pla         ;load status
2294 : 48              >            pha
                       >            cmp_flag fzc
2295 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2297 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2299 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
229a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
229c : 48              >            pha         ;use stack to load status
229d : a97e            >            lda #$7e     ;precharge accu
229f : 28              >            plp
                        
22a0 : d124                     cmp (ind1),y
                                tst_a $7e,fn
22a2 : 08              >            php         ;save flags
22a3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
22a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a7 : 68              >            pla         ;load status
22a8 : 48              >            pha
                       >            cmp_flag fn
22a9 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ad : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
22ae : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22b0 : 48              >            pha         ;use stack to load status
22b1 : a980            >            lda #$80     ;precharge accu
22b3 : 28              >            plp
                        
22b4 : d124                     cmp (ind1),y
                                tst_a $80,~fnz
22b6 : 08              >            php         ;save flags
22b7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
22b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22bb : 68              >            pla         ;load status
22bc : 48              >            pha
                       >            cmp_flag ~fnz
22bd : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c1 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
22c2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22c4 : 48              >            pha         ;use stack to load status
22c5 : a97f            >            lda #$7f     ;precharge accu
22c7 : 28              >            plp
                        
22c8 : d124                     cmp (ind1),y
                                tst_a $7f,~fn
22ca : 08              >            php         ;save flags
22cb : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
22cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22cf : 68              >            pla         ;load status
22d0 : 48              >            pha
                       >            cmp_flag ~fn
22d1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d5 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
22d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22d8 : 48              >            pha         ;use stack to load status
22d9 : a97e            >            lda #$7e     ;precharge accu
22db : 28              >            plp
                        
22dc : d124                     cmp (ind1),y
                                tst_a $7e,~fzc
22de : 08              >            php         ;save flags
22df : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
22e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e3 : 68              >            pla         ;load status
22e4 : 48              >            pha
                       >            cmp_flag ~fzc
22e5 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e9 : 28              >            plp         ;restore status
                        
                                next_test
22ea : ad0002          >            lda test_case   ;previous test
22ed : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
22f1 : a91d            >            lda #test_num   ;*** next tests' number
22f3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
22f6 : a203                     ldx #3
22f8 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
22f8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22fa : 48              >            pha         ;use stack to load status
22fb : b513            >            lda zp1,x    ;precharge accu
22fd : 28              >            plp
                        
22fe : 0a                       asl a
                                tst_ax rASL,fASL,0
22ff : 08              >            php         ;save flags
2300 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2303 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2305 : 68              >            pla         ;load status
                       >            eor_flag 0
2306 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2308 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
230b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
230d : ca                       dex
230e : 10e8                     bpl tasl
2310 : a203                     ldx #3
2312 :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
2312 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2314 : 48              >            pha         ;use stack to load status
2315 : b513            >            lda zp1,x    ;precharge accu
2317 : 28              >            plp
                        
2318 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
2319 : 08              >            php         ;save flags
231a : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
231d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
231f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2320 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2322 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
2325 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2327 : ca                       dex
2328 : 10e8                     bpl tasl1
                        
232a : a203                     ldx #3
232c :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
232c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
232e : 48              >            pha         ;use stack to load status
232f : b513            >            lda zp1,x    ;precharge accu
2331 : 28              >            plp
                        
2332 : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
2333 : 08              >            php         ;save flags
2334 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2337 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2339 : 68              >            pla         ;load status
                       >            eor_flag 0
233a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
233c : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
233f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2341 : ca                       dex
2342 : 10e8                     bpl tlsr
2344 : a203                     ldx #3
2346 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
2346 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2348 : 48              >            pha         ;use stack to load status
2349 : b513            >            lda zp1,x    ;precharge accu
234b : 28              >            plp
                        
234c : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
234d : 08              >            php         ;save flags
234e : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2351 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2353 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2354 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2356 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2359 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
235b : ca                       dex
235c : 10e8                     bpl tlsr1
                        
235e : a203                     ldx #3
2360 :                  trol
                                set_ax zp1,0
                       >            load_flag 0
2360 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2362 : 48              >            pha         ;use stack to load status
2363 : b513            >            lda zp1,x    ;precharge accu
2365 : 28              >            plp
                        
2366 : 2a                       rol a
                                tst_ax rROL,fROL,0
2367 : 08              >            php         ;save flags
2368 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
236b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
236d : 68              >            pla         ;load status
                       >            eor_flag 0
236e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2370 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2373 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2375 : ca                       dex
2376 : 10e8                     bpl trol
2378 : a203                     ldx #3
237a :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
237a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
237c : 48              >            pha         ;use stack to load status
237d : b513            >            lda zp1,x    ;precharge accu
237f : 28              >            plp
                        
2380 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2381 : 08              >            php         ;save flags
2382 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2385 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2387 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2388 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
238a : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
238d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
238f : ca                       dex
2390 : 10e8                     bpl trol1
                        
2392 : a203                     ldx #3
2394 :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
2394 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2396 : 48              >            pha         ;use stack to load status
2397 : b513            >            lda zp1,x    ;precharge accu
2399 : 28              >            plp
                        
239a : 2a                       rol a
                                tst_ax rROLc,fROLc,0
239b : 08              >            php         ;save flags
239c : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
239f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23a1 : 68              >            pla         ;load status
                       >            eor_flag 0
23a2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23a4 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
23a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23a9 : ca                       dex
23aa : 10e8                     bpl trolc
23ac : a203                     ldx #3
23ae :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
23ae : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
23b0 : 48              >            pha         ;use stack to load status
23b1 : b513            >            lda zp1,x    ;precharge accu
23b3 : 28              >            plp
                        
23b4 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
23b5 : 08              >            php         ;save flags
23b6 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
23b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23bb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23bc : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23be : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
23c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23c3 : ca                       dex
23c4 : 10e8                     bpl trolc1
                        
23c6 : a203                     ldx #3
23c8 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
23c8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23ca : 48              >            pha         ;use stack to load status
23cb : b513            >            lda zp1,x    ;precharge accu
23cd : 28              >            plp
                        
23ce : 6a                       ror a
                                tst_ax rROR,fROR,0
23cf : 08              >            php         ;save flags
23d0 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
23d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23d5 : 68              >            pla         ;load status
                       >            eor_flag 0
23d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23d8 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
23db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23dd : ca                       dex
23de : 10e8                     bpl tror
23e0 : a203                     ldx #3
23e2 :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
23e2 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
23e4 : 48              >            pha         ;use stack to load status
23e5 : b513            >            lda zp1,x    ;precharge accu
23e7 : 28              >            plp
                        
23e8 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
23e9 : 08              >            php         ;save flags
23ea : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
23ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ef : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23f0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23f2 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
23f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23f7 : ca                       dex
23f8 : 10e8                     bpl tror1
                        
23fa : a203                     ldx #3
23fc :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
23fc : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
23fe : 48              >            pha         ;use stack to load status
23ff : b513            >            lda zp1,x    ;precharge accu
2401 : 28              >            plp
                        
2402 : 6a                       ror a
                                tst_ax rRORc,fRORc,0
2403 : 08              >            php         ;save flags
2404 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2407 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2409 : 68              >            pla         ;load status
                       >            eor_flag 0
240a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
240c : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
240f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2411 : ca                       dex
2412 : 10e8                     bpl trorc
2414 : a203                     ldx #3
2416 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2416 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2418 : 48              >            pha         ;use stack to load status
2419 : b513            >            lda zp1,x    ;precharge accu
241b : 28              >            plp
                        
241c : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
241d : 08              >            php         ;save flags
241e : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2421 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2423 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2424 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2426 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
2429 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
242b : ca                       dex
242c : 10e8                     bpl trorc1
                                next_test
242e : ad0002          >            lda test_case   ;previous test
2431 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2433 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
2435 : a91e            >            lda #test_num   ;*** next tests' number
2437 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
243a : a203                     ldx #3
243c :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
243c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
243e : 48              >            pha         ;use stack to load status
243f : b513            >            lda zp1,x    ;load to zeropage
2441 : 850c            >            sta zpt
2443 : 28              >            plp
                        
2444 : 060c                     asl zpt
                                tst_z rASL,fASL,0
2446 : 08              >            php         ;save flags
2447 : a50c            >            lda zpt
2449 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
244c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
244e : 68              >            pla         ;load status
                       >            eor_flag 0
244f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2451 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2454 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2456 : ca                       dex
2457 : 10e3                     bpl tasl2
2459 : a203                     ldx #3
245b :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
245b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
245d : 48              >            pha         ;use stack to load status
245e : b513            >            lda zp1,x    ;load to zeropage
2460 : 850c            >            sta zpt
2462 : 28              >            plp
                        
2463 : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2465 : 08              >            php         ;save flags
2466 : a50c            >            lda zpt
2468 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
246b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
246d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
246e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2470 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2473 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2475 : ca                       dex
2476 : 10e3                     bpl tasl3
                        
2478 : a203                     ldx #3
247a :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
247a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
247c : 48              >            pha         ;use stack to load status
247d : b513            >            lda zp1,x    ;load to zeropage
247f : 850c            >            sta zpt
2481 : 28              >            plp
                        
2482 : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
2484 : 08              >            php         ;save flags
2485 : a50c            >            lda zpt
2487 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
248a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
248c : 68              >            pla         ;load status
                       >            eor_flag 0
248d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
248f : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2492 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2494 : ca                       dex
2495 : 10e3                     bpl tlsr2
2497 : a203                     ldx #3
2499 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2499 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
249b : 48              >            pha         ;use stack to load status
249c : b513            >            lda zp1,x    ;load to zeropage
249e : 850c            >            sta zpt
24a0 : 28              >            plp
                        
24a1 : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
24a3 : 08              >            php         ;save flags
24a4 : a50c            >            lda zpt
24a6 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
24a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24ac : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24ae : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
24b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24b3 : ca                       dex
24b4 : 10e3                     bpl tlsr3
                        
24b6 : a203                     ldx #3
24b8 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
24b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24ba : 48              >            pha         ;use stack to load status
24bb : b513            >            lda zp1,x    ;load to zeropage
24bd : 850c            >            sta zpt
24bf : 28              >            plp
                        
24c0 : 260c                     rol zpt
                                tst_z rROL,fROL,0
24c2 : 08              >            php         ;save flags
24c3 : a50c            >            lda zpt
24c5 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
24c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ca : 68              >            pla         ;load status
                       >            eor_flag 0
24cb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24cd : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
24d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24d2 : ca                       dex
24d3 : 10e3                     bpl trol2
24d5 : a203                     ldx #3
24d7 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24d7 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24d9 : 48              >            pha         ;use stack to load status
24da : b513            >            lda zp1,x    ;load to zeropage
24dc : 850c            >            sta zpt
24de : 28              >            plp
                        
24df : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
24e1 : 08              >            php         ;save flags
24e2 : a50c            >            lda zpt
24e4 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
24e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24e9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24ea : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24ec : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
24ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24f1 : ca                       dex
24f2 : 10e3                     bpl trol3
                        
24f4 : a203                     ldx #3
24f6 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
24f6 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
24f8 : 48              >            pha         ;use stack to load status
24f9 : b513            >            lda zp1,x    ;load to zeropage
24fb : 850c            >            sta zpt
24fd : 28              >            plp
                        
24fe : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
2500 : 08              >            php         ;save flags
2501 : a50c            >            lda zpt
2503 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2506 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2508 : 68              >            pla         ;load status
                       >            eor_flag 0
2509 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
250b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
250e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2510 : ca                       dex
2511 : 10e3                     bpl trolc2
2513 : a203                     ldx #3
2515 :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
2515 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2517 : 48              >            pha         ;use stack to load status
2518 : b513            >            lda zp1,x    ;load to zeropage
251a : 850c            >            sta zpt
251c : 28              >            plp
                        
251d : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
251f : 08              >            php         ;save flags
2520 : a50c            >            lda zpt
2522 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2525 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2527 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2528 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
252a : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
252d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
252f : ca                       dex
2530 : 10e3                     bpl trolc3
                        
2532 : a203                     ldx #3
2534 :                  tror2
                                set_z zp1,0
                       >            load_flag 0
2534 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2536 : 48              >            pha         ;use stack to load status
2537 : b513            >            lda zp1,x    ;load to zeropage
2539 : 850c            >            sta zpt
253b : 28              >            plp
                        
253c : 660c                     ror zpt
                                tst_z rROR,fROR,0
253e : 08              >            php         ;save flags
253f : a50c            >            lda zpt
2541 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2544 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2546 : 68              >            pla         ;load status
                       >            eor_flag 0
2547 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2549 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
254c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
254e : ca                       dex
254f : 10e3                     bpl tror2
2551 : a203                     ldx #3
2553 :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2553 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2555 : 48              >            pha         ;use stack to load status
2556 : b513            >            lda zp1,x    ;load to zeropage
2558 : 850c            >            sta zpt
255a : 28              >            plp
                        
255b : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
255d : 08              >            php         ;save flags
255e : a50c            >            lda zpt
2560 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2563 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2565 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2566 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2568 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
256b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
256d : ca                       dex
256e : 10e3                     bpl tror3
                        
2570 : a203                     ldx #3
2572 :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
2572 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2574 : 48              >            pha         ;use stack to load status
2575 : b513            >            lda zp1,x    ;load to zeropage
2577 : 850c            >            sta zpt
2579 : 28              >            plp
                        
257a : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
257c : 08              >            php         ;save flags
257d : a50c            >            lda zpt
257f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2582 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2584 : 68              >            pla         ;load status
                       >            eor_flag 0
2585 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2587 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
258a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
258c : ca                       dex
258d : 10e3                     bpl trorc2
258f : a203                     ldx #3
2591 :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
2591 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2593 : 48              >            pha         ;use stack to load status
2594 : b513            >            lda zp1,x    ;load to zeropage
2596 : 850c            >            sta zpt
2598 : 28              >            plp
                        
2599 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
259b : 08              >            php         ;save flags
259c : a50c            >            lda zpt
259e : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
25a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25a3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25a4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25a6 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
25a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25ab : ca                       dex
25ac : 10e3                     bpl trorc3
                                next_test
25ae : ad0002          >            lda test_case   ;previous test
25b1 : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
25b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
25b5 : a91f            >            lda #test_num   ;*** next tests' number
25b7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
25ba : a203                     ldx #3
25bc :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
25bc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25be : 48              >            pha         ;use stack to load status
25bf : b513            >            lda zp1,x    ;load to memory
25c1 : 8d0302          >            sta abst
25c4 : 28              >            plp
                        
25c5 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
25c8 : 08              >            php         ;save flags
25c9 : ad0302          >            lda abst
25cc : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
25cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25d1 : 68              >            pla         ;load status
                       >            eor_flag 0
25d2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25d4 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25d9 : ca                       dex
25da : 10e0                     bpl tasl4
25dc : a203                     ldx #3
25de :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
25de : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25e0 : 48              >            pha         ;use stack to load status
25e1 : b513            >            lda zp1,x    ;load to memory
25e3 : 8d0302          >            sta abst
25e6 : 28              >            plp
                        
25e7 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
25ea : 08              >            php         ;save flags
25eb : ad0302          >            lda abst
25ee : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
25f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25f3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25f4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25f6 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25fb : ca                       dex
25fc : 10e0                     bpl tasl5
                        
25fe : a203                     ldx #3
2600 :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
2600 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2602 : 48              >            pha         ;use stack to load status
2603 : b513            >            lda zp1,x    ;load to memory
2605 : 8d0302          >            sta abst
2608 : 28              >            plp
                        
2609 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
260c : 08              >            php         ;save flags
260d : ad0302          >            lda abst
2610 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2613 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2615 : 68              >            pla         ;load status
                       >            eor_flag 0
2616 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2618 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
261b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
261d : ca                       dex
261e : 10e0                     bpl tlsr4
2620 : a203                     ldx #3
2622 :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
2622 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2624 : 48              >            pha         ;use stack to load status
2625 : b513            >            lda zp1,x    ;load to memory
2627 : 8d0302          >            sta abst
262a : 28              >            plp
                        
262b : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
262e : 08              >            php         ;save flags
262f : ad0302          >            lda abst
2632 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2635 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2637 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2638 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
263a : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
263d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
263f : ca                       dex
2640 : 10e0                     bpl tlsr5
                        
2642 : a203                     ldx #3
2644 :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
2644 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2646 : 48              >            pha         ;use stack to load status
2647 : b513            >            lda zp1,x    ;load to memory
2649 : 8d0302          >            sta abst
264c : 28              >            plp
                        
264d : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
2650 : 08              >            php         ;save flags
2651 : ad0302          >            lda abst
2654 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2657 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2659 : 68              >            pla         ;load status
                       >            eor_flag 0
265a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
265c : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
265f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2661 : ca                       dex
2662 : 10e0                     bpl trol4
2664 : a203                     ldx #3
2666 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2666 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2668 : 48              >            pha         ;use stack to load status
2669 : b513            >            lda zp1,x    ;load to memory
266b : 8d0302          >            sta abst
266e : 28              >            plp
                        
266f : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2672 : 08              >            php         ;save flags
2673 : ad0302          >            lda abst
2676 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2679 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
267b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
267c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
267e : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2681 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2683 : ca                       dex
2684 : 10e0                     bpl trol5
                        
2686 : a203                     ldx #3
2688 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2688 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
268a : 48              >            pha         ;use stack to load status
268b : b513            >            lda zp1,x    ;load to memory
268d : 8d0302          >            sta abst
2690 : 28              >            plp
                        
2691 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2694 : 08              >            php         ;save flags
2695 : ad0302          >            lda abst
2698 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
269b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
269d : 68              >            pla         ;load status
                       >            eor_flag 0
269e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26a0 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26a5 : ca                       dex
26a6 : 10e0                     bpl trolc4
26a8 : a203                     ldx #3
26aa :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
26aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
26ac : 48              >            pha         ;use stack to load status
26ad : b513            >            lda zp1,x    ;load to memory
26af : 8d0302          >            sta abst
26b2 : 28              >            plp
                        
26b3 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
26b6 : 08              >            php         ;save flags
26b7 : ad0302          >            lda abst
26ba : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
26bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26bf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26c0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26c2 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26c7 : ca                       dex
26c8 : 10e0                     bpl trolc5
                        
26ca : a203                     ldx #3
26cc :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
26cc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26ce : 48              >            pha         ;use stack to load status
26cf : b513            >            lda zp1,x    ;load to memory
26d1 : 8d0302          >            sta abst
26d4 : 28              >            plp
                        
26d5 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
26d8 : 08              >            php         ;save flags
26d9 : ad0302          >            lda abst
26dc : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
26df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26e1 : 68              >            pla         ;load status
                       >            eor_flag 0
26e2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26e4 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
26e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26e9 : ca                       dex
26ea : 10e0                     bpl tror4
26ec : a203                     ldx #3
26ee :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
26ee : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
26f0 : 48              >            pha         ;use stack to load status
26f1 : b513            >            lda zp1,x    ;load to memory
26f3 : 8d0302          >            sta abst
26f6 : 28              >            plp
                        
26f7 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
26fa : 08              >            php         ;save flags
26fb : ad0302          >            lda abst
26fe : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2701 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2703 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2704 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2706 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2709 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
270b : ca                       dex
270c : 10e0                     bpl tror5
                        
270e : a203                     ldx #3
2710 :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
2710 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2712 : 48              >            pha         ;use stack to load status
2713 : b513            >            lda zp1,x    ;load to memory
2715 : 8d0302          >            sta abst
2718 : 28              >            plp
                        
2719 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
271c : 08              >            php         ;save flags
271d : ad0302          >            lda abst
2720 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2723 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2725 : 68              >            pla         ;load status
                       >            eor_flag 0
2726 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2728 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
272b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
272d : ca                       dex
272e : 10e0                     bpl trorc4
2730 : a203                     ldx #3
2732 :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2732 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2734 : 48              >            pha         ;use stack to load status
2735 : b513            >            lda zp1,x    ;load to memory
2737 : 8d0302          >            sta abst
273a : 28              >            plp
                        
273b : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
273e : 08              >            php         ;save flags
273f : ad0302          >            lda abst
2742 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2745 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2747 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2748 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
274a : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
274d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
274f : ca                       dex
2750 : 10e0                     bpl trorc5
                                next_test
2752 : ad0002          >            lda test_case   ;previous test
2755 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2757 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2759 : a920            >            lda #test_num   ;*** next tests' number
275b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
275e : a203                     ldx #3
2760 :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
2760 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2762 : 48              >            pha         ;use stack to load status
2763 : b513            >            lda zp1,x    ;load to indexed zeropage
2765 : 950c            >            sta zpt,x
2767 : 28              >            plp
                        
2768 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
276a : 08              >            php         ;save flags
276b : b50c            >            lda zpt,x
276d : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2770 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2772 : 68              >            pla         ;load status
                       >            eor_flag 0
2773 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2775 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2778 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
277a : ca                       dex
277b : 10e3                     bpl tasl6
277d : a203                     ldx #3
277f :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
277f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2781 : 48              >            pha         ;use stack to load status
2782 : b513            >            lda zp1,x    ;load to indexed zeropage
2784 : 950c            >            sta zpt,x
2786 : 28              >            plp
                        
2787 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2789 : 08              >            php         ;save flags
278a : b50c            >            lda zpt,x
278c : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
278f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2791 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2792 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2794 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2797 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2799 : ca                       dex
279a : 10e3                     bpl tasl7
                        
279c : a203                     ldx #3
279e :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
279e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27a0 : 48              >            pha         ;use stack to load status
27a1 : b513            >            lda zp1,x    ;load to indexed zeropage
27a3 : 950c            >            sta zpt,x
27a5 : 28              >            plp
                        
27a6 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
27a8 : 08              >            php         ;save flags
27a9 : b50c            >            lda zpt,x
27ab : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
27ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27b0 : 68              >            pla         ;load status
                       >            eor_flag 0
27b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27b3 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27b8 : ca                       dex
27b9 : 10e3                     bpl tlsr6
27bb : a203                     ldx #3
27bd :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
27bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27bf : 48              >            pha         ;use stack to load status
27c0 : b513            >            lda zp1,x    ;load to indexed zeropage
27c2 : 950c            >            sta zpt,x
27c4 : 28              >            plp
                        
27c5 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
27c7 : 08              >            php         ;save flags
27c8 : b50c            >            lda zpt,x
27ca : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
27cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27cf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27d0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27d2 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27d7 : ca                       dex
27d8 : 10e3                     bpl tlsr7
                        
27da : a203                     ldx #3
27dc :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
27dc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27de : 48              >            pha         ;use stack to load status
27df : b513            >            lda zp1,x    ;load to indexed zeropage
27e1 : 950c            >            sta zpt,x
27e3 : 28              >            plp
                        
27e4 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
27e6 : 08              >            php         ;save flags
27e7 : b50c            >            lda zpt,x
27e9 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
27ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ee : 68              >            pla         ;load status
                       >            eor_flag 0
27ef : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27f1 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
27f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27f6 : ca                       dex
27f7 : 10e3                     bpl trol6
27f9 : a203                     ldx #3
27fb :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27fb : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27fd : 48              >            pha         ;use stack to load status
27fe : b513            >            lda zp1,x    ;load to indexed zeropage
2800 : 950c            >            sta zpt,x
2802 : 28              >            plp
                        
2803 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2805 : 08              >            php         ;save flags
2806 : b50c            >            lda zpt,x
2808 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
280b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
280d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
280e : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2810 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2813 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2815 : ca                       dex
2816 : 10e3                     bpl trol7
                        
2818 : a203                     ldx #3
281a :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
281a : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
281c : 48              >            pha         ;use stack to load status
281d : b513            >            lda zp1,x    ;load to indexed zeropage
281f : 950c            >            sta zpt,x
2821 : 28              >            plp
                        
2822 : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
2824 : 08              >            php         ;save flags
2825 : b50c            >            lda zpt,x
2827 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
282a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
282c : 68              >            pla         ;load status
                       >            eor_flag 0
282d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
282f : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2832 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2834 : ca                       dex
2835 : 10e3                     bpl trolc6
2837 : a203                     ldx #3
2839 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2839 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
283b : 48              >            pha         ;use stack to load status
283c : b513            >            lda zp1,x    ;load to indexed zeropage
283e : 950c            >            sta zpt,x
2840 : 28              >            plp
                        
2841 : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
2843 : 08              >            php         ;save flags
2844 : b50c            >            lda zpt,x
2846 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2849 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
284b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
284c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
284e : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2851 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2853 : ca                       dex
2854 : 10e3                     bpl trolc7
                        
2856 : a203                     ldx #3
2858 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
2858 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
285a : 48              >            pha         ;use stack to load status
285b : b513            >            lda zp1,x    ;load to indexed zeropage
285d : 950c            >            sta zpt,x
285f : 28              >            plp
                        
2860 : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
2862 : 08              >            php         ;save flags
2863 : b50c            >            lda zpt,x
2865 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2868 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
286a : 68              >            pla         ;load status
                       >            eor_flag 0
286b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
286d : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2870 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2872 : ca                       dex
2873 : 10e3                     bpl tror6
2875 : a203                     ldx #3
2877 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2877 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2879 : 48              >            pha         ;use stack to load status
287a : b513            >            lda zp1,x    ;load to indexed zeropage
287c : 950c            >            sta zpt,x
287e : 28              >            plp
                        
287f : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2881 : 08              >            php         ;save flags
2882 : b50c            >            lda zpt,x
2884 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2887 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2889 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
288a : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
288c : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
288f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2891 : ca                       dex
2892 : 10e3                     bpl tror7
                        
2894 : a203                     ldx #3
2896 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2896 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2898 : 48              >            pha         ;use stack to load status
2899 : b513            >            lda zp1,x    ;load to indexed zeropage
289b : 950c            >            sta zpt,x
289d : 28              >            plp
                        
289e : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
28a0 : 08              >            php         ;save flags
28a1 : b50c            >            lda zpt,x
28a3 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
28a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28a8 : 68              >            pla         ;load status
                       >            eor_flag 0
28a9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28ab : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
28ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28b0 : ca                       dex
28b1 : 10e3                     bpl trorc6
28b3 : a203                     ldx #3
28b5 :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
28b5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28b7 : 48              >            pha         ;use stack to load status
28b8 : b513            >            lda zp1,x    ;load to indexed zeropage
28ba : 950c            >            sta zpt,x
28bc : 28              >            plp
                        
28bd : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
28bf : 08              >            php         ;save flags
28c0 : b50c            >            lda zpt,x
28c2 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
28c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28c7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28c8 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28ca : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
28cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28cf : ca                       dex
28d0 : 10e3                     bpl trorc7
                                next_test
28d2 : ad0002          >            lda test_case   ;previous test
28d5 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
28d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
28d9 : a921            >            lda #test_num   ;*** next tests' number
28db : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
28de : a203                     ldx #3
28e0 :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
28e0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28e2 : 48              >            pha         ;use stack to load status
28e3 : b513            >            lda zp1,x    ;load to indexed memory
28e5 : 9d0302          >            sta abst,x
28e8 : 28              >            plp
                        
28e9 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
28ec : 08              >            php         ;save flags
28ed : bd0302          >            lda abst,x
28f0 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
28f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28f5 : 68              >            pla         ;load status
                       >            eor_flag 0
28f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28f8 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28fd : ca                       dex
28fe : 10e0                     bpl tasl8
2900 : a203                     ldx #3
2902 :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
2902 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2904 : 48              >            pha         ;use stack to load status
2905 : b513            >            lda zp1,x    ;load to indexed memory
2907 : 9d0302          >            sta abst,x
290a : 28              >            plp
                        
290b : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
290e : 08              >            php         ;save flags
290f : bd0302          >            lda abst,x
2912 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2915 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2917 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2918 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
291a : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
291d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
291f : ca                       dex
2920 : 10e0                     bpl tasl9
                        
2922 : a203                     ldx #3
2924 :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
2924 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2926 : 48              >            pha         ;use stack to load status
2927 : b513            >            lda zp1,x    ;load to indexed memory
2929 : 9d0302          >            sta abst,x
292c : 28              >            plp
                        
292d : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
2930 : 08              >            php         ;save flags
2931 : bd0302          >            lda abst,x
2934 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2937 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2939 : 68              >            pla         ;load status
                       >            eor_flag 0
293a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
293c : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
293f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2941 : ca                       dex
2942 : 10e0                     bpl tlsr8
2944 : a203                     ldx #3
2946 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
2946 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2948 : 48              >            pha         ;use stack to load status
2949 : b513            >            lda zp1,x    ;load to indexed memory
294b : 9d0302          >            sta abst,x
294e : 28              >            plp
                        
294f : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
2952 : 08              >            php         ;save flags
2953 : bd0302          >            lda abst,x
2956 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2959 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
295b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
295c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
295e : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2961 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2963 : ca                       dex
2964 : 10e0                     bpl tlsr9
                        
2966 : a203                     ldx #3
2968 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
2968 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
296a : 48              >            pha         ;use stack to load status
296b : b513            >            lda zp1,x    ;load to indexed memory
296d : 9d0302          >            sta abst,x
2970 : 28              >            plp
                        
2971 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2974 : 08              >            php         ;save flags
2975 : bd0302          >            lda abst,x
2978 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
297b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
297d : 68              >            pla         ;load status
                       >            eor_flag 0
297e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2980 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2983 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2985 : ca                       dex
2986 : 10e0                     bpl trol8
2988 : a203                     ldx #3
298a :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
298a : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
298c : 48              >            pha         ;use stack to load status
298d : b513            >            lda zp1,x    ;load to indexed memory
298f : 9d0302          >            sta abst,x
2992 : 28              >            plp
                        
2993 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2996 : 08              >            php         ;save flags
2997 : bd0302          >            lda abst,x
299a : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
299d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
299f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29a0 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29a2 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
29a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29a7 : ca                       dex
29a8 : 10e0                     bpl trol9
                        
29aa : a203                     ldx #3
29ac :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
29ac : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
29ae : 48              >            pha         ;use stack to load status
29af : b513            >            lda zp1,x    ;load to indexed memory
29b1 : 9d0302          >            sta abst,x
29b4 : 28              >            plp
                        
29b5 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
29b8 : 08              >            php         ;save flags
29b9 : bd0302          >            lda abst,x
29bc : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
29bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c1 : 68              >            pla         ;load status
                       >            eor_flag 0
29c2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29c4 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
29c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29c9 : ca                       dex
29ca : 10e0                     bpl trolc8
29cc : a203                     ldx #3
29ce :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29ce : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29d0 : 48              >            pha         ;use stack to load status
29d1 : b513            >            lda zp1,x    ;load to indexed memory
29d3 : 9d0302          >            sta abst,x
29d6 : 28              >            plp
                        
29d7 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
29da : 08              >            php         ;save flags
29db : bd0302          >            lda abst,x
29de : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
29e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29e3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29e4 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29e6 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
29e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29eb : ca                       dex
29ec : 10e0                     bpl trolc9
                        
29ee : a203                     ldx #3
29f0 :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
29f0 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29f2 : 48              >            pha         ;use stack to load status
29f3 : b513            >            lda zp1,x    ;load to indexed memory
29f5 : 9d0302          >            sta abst,x
29f8 : 28              >            plp
                        
29f9 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
29fc : 08              >            php         ;save flags
29fd : bd0302          >            lda abst,x
2a00 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2a03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a05 : 68              >            pla         ;load status
                       >            eor_flag 0
2a06 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a08 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2a0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a0d : ca                       dex
2a0e : 10e0                     bpl tror8
2a10 : a203                     ldx #3
2a12 :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2a12 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2a14 : 48              >            pha         ;use stack to load status
2a15 : b513            >            lda zp1,x    ;load to indexed memory
2a17 : 9d0302          >            sta abst,x
2a1a : 28              >            plp
                        
2a1b : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2a1e : 08              >            php         ;save flags
2a1f : bd0302          >            lda abst,x
2a22 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2a25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a27 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a28 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a2a : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2a2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a2f : ca                       dex
2a30 : 10e0                     bpl tror9
                        
2a32 : a203                     ldx #3
2a34 :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
2a34 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2a36 : 48              >            pha         ;use stack to load status
2a37 : b513            >            lda zp1,x    ;load to indexed memory
2a39 : 9d0302          >            sta abst,x
2a3c : 28              >            plp
                        
2a3d : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
2a40 : 08              >            php         ;save flags
2a41 : bd0302          >            lda abst,x
2a44 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a49 : 68              >            pla         ;load status
                       >            eor_flag 0
2a4a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a4c : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a51 : ca                       dex
2a52 : 10e0                     bpl trorc8
2a54 : a203                     ldx #3
2a56 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2a56 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a58 : 48              >            pha         ;use stack to load status
2a59 : b513            >            lda zp1,x    ;load to indexed memory
2a5b : 9d0302          >            sta abst,x
2a5e : 28              >            plp
                        
2a5f : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2a62 : 08              >            php         ;save flags
2a63 : bd0302          >            lda abst,x
2a66 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a6b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a6c : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a6e : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a73 : ca                       dex
2a74 : 10e0                     bpl trorc9
                                next_test
2a76 : ad0002          >            lda test_case   ;previous test
2a79 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2a7d : a922            >            lda #test_num   ;*** next tests' number
2a7f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a82 : a200                     ldx #0
2a84 : a97e                     lda #$7e
2a86 : 850c                     sta zpt
2a88 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a88 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a8a : 48              >            pha         ;use stack to load status
2a8b : 28              >            plp
                        
2a8c : e60c                     inc zpt
                                tst_z rINC,fINC,0
2a8e : 08              >            php         ;save flags
2a8f : a50c            >            lda zpt
2a91 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a96 : 68              >            pla         ;load status
                       >            eor_flag 0
2a97 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a99 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a9e : e8                       inx
2a9f : e002                     cpx #2
2aa1 : d004                     bne tinc1
2aa3 : a9fe                     lda #$fe
2aa5 : 850c                     sta zpt
2aa7 : e005             tinc1   cpx #5
2aa9 : d0dd                     bne tinc
2aab : ca                       dex
2aac : e60c                     inc zpt
2aae :                  tdec    
                                set_stat 0
                       >            load_flag 0
2aae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ab0 : 48              >            pha         ;use stack to load status
2ab1 : 28              >            plp
                        
2ab2 : c60c                     dec zpt
                                tst_z rINC,fINC,0
2ab4 : 08              >            php         ;save flags
2ab5 : a50c            >            lda zpt
2ab7 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2aba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2abc : 68              >            pla         ;load status
                       >            eor_flag 0
2abd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2abf : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ac2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ac4 : ca                       dex
2ac5 : 300a                     bmi tdec1
2ac7 : e001                     cpx #1
2ac9 : d0e3                     bne tdec
2acb : a981                     lda #$81
2acd : 850c                     sta zpt
2acf : d0dd                     bne tdec
2ad1 :                  tdec1
2ad1 : a200                     ldx #0
2ad3 : a97e                     lda #$7e
2ad5 : 850c                     sta zpt
2ad7 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2ad7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ad9 : 48              >            pha         ;use stack to load status
2ada : 28              >            plp
                        
2adb : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2add : 08              >            php         ;save flags
2ade : a50c            >            lda zpt
2ae0 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ae3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ae5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ae6 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ae8 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aeb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2aed : e8                       inx
2aee : e002                     cpx #2
2af0 : d004                     bne tinc11
2af2 : a9fe                     lda #$fe
2af4 : 850c                     sta zpt
2af6 : e005             tinc11  cpx #5
2af8 : d0dd                     bne tinc10
2afa : ca                       dex
2afb : e60c                     inc zpt
2afd :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2afd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2aff : 48              >            pha         ;use stack to load status
2b00 : 28              >            plp
                        
2b01 : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2b03 : 08              >            php         ;save flags
2b04 : a50c            >            lda zpt
2b06 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b0b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b0c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b0e : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b13 : ca                       dex
2b14 : 300a                     bmi tdec11
2b16 : e001                     cpx #1
2b18 : d0e3                     bne tdec10
2b1a : a981                     lda #$81
2b1c : 850c                     sta zpt
2b1e : d0dd                     bne tdec10
2b20 :                  tdec11
                                next_test
2b20 : ad0002          >            lda test_case   ;previous test
2b23 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2b27 : a923            >            lda #test_num   ;*** next tests' number
2b29 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2b2c : a200                     ldx #0
2b2e : a97e                     lda #$7e
2b30 : 8d0302                   sta abst
2b33 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2b33 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b35 : 48              >            pha         ;use stack to load status
2b36 : 28              >            plp
                        
2b37 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2b3a : 08              >            php         ;save flags
2b3b : ad0302          >            lda abst
2b3e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b43 : 68              >            pla         ;load status
                       >            eor_flag 0
2b44 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b46 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b4b : e8                       inx
2b4c : e002                     cpx #2
2b4e : d005                     bne tinc3
2b50 : a9fe                     lda #$fe
2b52 : 8d0302                   sta abst
2b55 : e005             tinc3   cpx #5
2b57 : d0da                     bne tinc2
2b59 : ca                       dex
2b5a : ee0302                   inc abst
2b5d :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2b5d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b5f : 48              >            pha         ;use stack to load status
2b60 : 28              >            plp
                        
2b61 : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2b64 : 08              >            php         ;save flags
2b65 : ad0302          >            lda abst
2b68 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b6d : 68              >            pla         ;load status
                       >            eor_flag 0
2b6e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b70 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b75 : ca                       dex
2b76 : 300b                     bmi tdec3
2b78 : e001                     cpx #1
2b7a : d0e1                     bne tdec2
2b7c : a981                     lda #$81
2b7e : 8d0302                   sta abst
2b81 : d0da                     bne tdec2
2b83 :                  tdec3
2b83 : a200                     ldx #0
2b85 : a97e                     lda #$7e
2b87 : 8d0302                   sta abst
2b8a :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b8a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b8c : 48              >            pha         ;use stack to load status
2b8d : 28              >            plp
                        
2b8e : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b91 : 08              >            php         ;save flags
2b92 : ad0302          >            lda abst
2b95 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b9a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b9b : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b9d : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ba0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ba2 : e8                       inx
2ba3 : e002                     cpx #2
2ba5 : d005                     bne tinc13
2ba7 : a9fe                     lda #$fe
2ba9 : 8d0302                   sta abst
2bac : e005             tinc13   cpx #5
2bae : d0da                     bne tinc12
2bb0 : ca                       dex
2bb1 : ee0302                   inc abst
2bb4 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2bb4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2bb6 : 48              >            pha         ;use stack to load status
2bb7 : 28              >            plp
                        
2bb8 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2bbb : 08              >            php         ;save flags
2bbc : ad0302          >            lda abst
2bbf : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bc4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bc5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bc7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bcc : ca                       dex
2bcd : 300b                     bmi tdec13
2bcf : e001                     cpx #1
2bd1 : d0e1                     bne tdec12
2bd3 : a981                     lda #$81
2bd5 : 8d0302                   sta abst
2bd8 : d0da                     bne tdec12
2bda :                  tdec13
                                next_test
2bda : ad0002          >            lda test_case   ;previous test
2bdd : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2bdf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2be1 : a924            >            lda #test_num   ;*** next tests' number
2be3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2be6 : a200                     ldx #0
2be8 : a97e                     lda #$7e
2bea : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2bec : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2bee : 48              >            pha         ;use stack to load status
2bef : 28              >            plp
                        
2bf0 : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2bf2 : 08              >            php         ;save flags
2bf3 : b50c            >            lda zpt,x
2bf5 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bfa : 68              >            pla         ;load status
                       >            eor_flag 0
2bfb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bfd : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c02 : b50c                     lda zpt,x
2c04 : e8                       inx
2c05 : e002                     cpx #2
2c07 : d002                     bne tinc5
2c09 : a9fe                     lda #$fe
2c0b : e005             tinc5   cpx #5
2c0d : d0db                     bne tinc4
2c0f : ca                       dex
2c10 : a902                     lda #2
2c12 : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2c14 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c16 : 48              >            pha         ;use stack to load status
2c17 : 28              >            plp
                        
2c18 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2c1a : 08              >            php         ;save flags
2c1b : b50c            >            lda zpt,x
2c1d : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c22 : 68              >            pla         ;load status
                       >            eor_flag 0
2c23 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c25 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c2a : b50c                     lda zpt,x
2c2c : ca                       dex
2c2d : 3008                     bmi tdec5
2c2f : e001                     cpx #1
2c31 : d0df                     bne tdec4
2c33 : a981                     lda #$81
2c35 : d0db                     bne tdec4
2c37 :                  tdec5
2c37 : a200                     ldx #0
2c39 : a97e                     lda #$7e
2c3b : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2c3d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c3f : 48              >            pha         ;use stack to load status
2c40 : 28              >            plp
                        
2c41 : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c43 : 08              >            php         ;save flags
2c44 : b50c            >            lda zpt,x
2c46 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c4b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c4c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c4e : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c53 : b50c                     lda zpt,x
2c55 : e8                       inx
2c56 : e002                     cpx #2
2c58 : d002                     bne tinc15
2c5a : a9fe                     lda #$fe
2c5c : e005             tinc15  cpx #5
2c5e : d0db                     bne tinc14
2c60 : ca                       dex
2c61 : a902                     lda #2
2c63 : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2c65 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c67 : 48              >            pha         ;use stack to load status
2c68 : 28              >            plp
                        
2c69 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c6b : 08              >            php         ;save flags
2c6c : b50c            >            lda zpt,x
2c6e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c73 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c74 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c76 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c7b : b50c                     lda zpt,x
2c7d : ca                       dex
2c7e : 3008                     bmi tdec15
2c80 : e001                     cpx #1
2c82 : d0df                     bne tdec14
2c84 : a981                     lda #$81
2c86 : d0db                     bne tdec14
2c88 :                  tdec15
                                next_test
2c88 : ad0002          >            lda test_case   ;previous test
2c8b : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c8f : a925            >            lda #test_num   ;*** next tests' number
2c91 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c94 : a200                     ldx #0
2c96 : a97e                     lda #$7e
2c98 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c9b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c9d : 48              >            pha         ;use stack to load status
2c9e : 28              >            plp
                        
2c9f : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2ca2 : 08              >            php         ;save flags
2ca3 : bd0302          >            lda abst,x
2ca6 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ca9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cab : 68              >            pla         ;load status
                       >            eor_flag 0
2cac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cae : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb3 : bd0302                   lda abst,x
2cb6 : e8                       inx
2cb7 : e002                     cpx #2
2cb9 : d002                     bne tinc7
2cbb : a9fe                     lda #$fe
2cbd : e005             tinc7   cpx #5
2cbf : d0d7                     bne tinc6
2cc1 : ca                       dex
2cc2 : a902                     lda #2
2cc4 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2cc7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cc9 : 48              >            pha         ;use stack to load status
2cca : 28              >            plp
                        
2ccb : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2cce : 08              >            php         ;save flags
2ccf : bd0302          >            lda abst,x
2cd2 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cd7 : 68              >            pla         ;load status
                       >            eor_flag 0
2cd8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cda : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cdf : bd0302                   lda abst,x
2ce2 : ca                       dex
2ce3 : 3008                     bmi tdec7
2ce5 : e001                     cpx #1
2ce7 : d0db                     bne tdec6
2ce9 : a981                     lda #$81
2ceb : d0d7                     bne tdec6
2ced :                  tdec7
2ced : a200                     ldx #0
2cef : a97e                     lda #$7e
2cf1 : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2cf4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2cf6 : 48              >            pha         ;use stack to load status
2cf7 : 28              >            plp
                        
2cf8 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2cfb : 08              >            php         ;save flags
2cfc : bd0302          >            lda abst,x
2cff : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2d02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d04 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d05 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d07 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d0c : bd0302                   lda abst,x
2d0f : e8                       inx
2d10 : e002                     cpx #2
2d12 : d002                     bne tinc17
2d14 : a9fe                     lda #$fe
2d16 : e005             tinc17  cpx #5
2d18 : d0d7                     bne tinc16
2d1a : ca                       dex
2d1b : a902                     lda #2
2d1d : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2d20 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d22 : 48              >            pha         ;use stack to load status
2d23 : 28              >            plp
                        
2d24 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2d27 : 08              >            php         ;save flags
2d28 : bd0302          >            lda abst,x
2d2b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d30 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d31 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d33 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d38 : bd0302                   lda abst,x
2d3b : ca                       dex
2d3c : 3008                     bmi tdec17
2d3e : e001                     cpx #1
2d40 : d0db                     bne tdec16
2d42 : a981                     lda #$81
2d44 : d0d7                     bne tdec16
2d46 :                  tdec17
                                next_test
2d46 : ad0002          >            lda test_case   ;previous test
2d49 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2d4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2d4d : a926            >            lda #test_num   ;*** next tests' number
2d4f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2d52 : a203                     ldx #3          ;immediate
2d54 : b51c             tand    lda zpAN,x
2d56 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2d59 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d5b : 48              >            pha         ;use stack to load status
2d5c : bd5a02          >            lda absANa,x    ;precharge accu
2d5f : 28              >            plp
                        
2d60 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2d63 : 08              >            php         ;save flags
2d64 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d69 : 68              >            pla         ;load status
                       >            eor_flag 0
2d6a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d6c : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d71 : ca                       dex
2d72 : 10e0                     bpl tand
2d74 : a203                     ldx #3
2d76 : b51c             tand1   lda zpAN,x
2d78 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d7b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d7d : 48              >            pha         ;use stack to load status
2d7e : bd5a02          >            lda absANa,x    ;precharge accu
2d81 : 28              >            plp
                        
2d82 : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d85 : 08              >            php         ;save flags
2d86 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d8b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d8c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d8e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d93 : ca                       dex
2d94 : 10e0                     bpl tand1
                            
2d96 : a203                     ldx #3      ;zp
2d98 : b51c             tand2   lda zpAN,x
2d9a : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d9c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d9e : 48              >            pha         ;use stack to load status
2d9f : bd5a02          >            lda absANa,x    ;precharge accu
2da2 : 28              >            plp
                        
2da3 : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
2da5 : 08              >            php         ;save flags
2da6 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2da9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dab : 68              >            pla         ;load status
                       >            eor_flag 0
2dac : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2dae : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2db1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2db3 : ca                       dex
2db4 : 10e2                     bpl tand2
2db6 : a203                     ldx #3
2db8 : b51c             tand3   lda zpAN,x
2dba : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dbc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dbe : 48              >            pha         ;use stack to load status
2dbf : bd5a02          >            lda absANa,x    ;precharge accu
2dc2 : 28              >            plp
                        
2dc3 : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2dc5 : 08              >            php         ;save flags
2dc6 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dcb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dcc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dce : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dd3 : ca                       dex
2dd4 : 10e2                     bpl tand3
                        
2dd6 : a203                     ldx #3      ;abs
2dd8 : b51c             tand4   lda zpAN,x
2dda : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2ddd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ddf : 48              >            pha         ;use stack to load status
2de0 : bd5a02          >            lda absANa,x    ;precharge accu
2de3 : 28              >            plp
                        
2de4 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2de7 : 08              >            php         ;save flags
2de8 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2deb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ded : 68              >            pla         ;load status
                       >            eor_flag 0
2dee : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2df0 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2df3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2df5 : ca                       dex
2df6 : 10e0                     bpl tand4
2df8 : a203                     ldx #3
2dfa : b51c             tand5   lda zpAN,x
2dfc : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e01 : 48              >            pha         ;use stack to load status
2e02 : bd5a02          >            lda absANa,x    ;precharge accu
2e05 : 28              >            plp
                        
2e06 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2e09 : 08              >            php         ;save flags
2e0a : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e0f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e10 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e12 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e17 : ca                       dex
2e18 : 1002                     bpl tand6
                        
2e1a : a203                     ldx #3      ;zp,x
2e1c :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2e1c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e1e : 48              >            pha         ;use stack to load status
2e1f : bd5a02          >            lda absANa,x    ;precharge accu
2e22 : 28              >            plp
                        
2e23 : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2e25 : 08              >            php         ;save flags
2e26 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e2b : 68              >            pla         ;load status
                       >            eor_flag 0
2e2c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e2e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e33 : ca                       dex
2e34 : 10e6                     bpl tand6
2e36 : a203                     ldx #3
2e38 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e38 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e3a : 48              >            pha         ;use stack to load status
2e3b : bd5a02          >            lda absANa,x    ;precharge accu
2e3e : 28              >            plp
                        
2e3f : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e41 : 08              >            php         ;save flags
2e42 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e47 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e48 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e4a : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e4f : ca                       dex
2e50 : 10e6                     bpl tand7
                        
2e52 : a203                     ldx #3      ;abs,x
2e54 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2e54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e56 : 48              >            pha         ;use stack to load status
2e57 : bd5a02          >            lda absANa,x    ;precharge accu
2e5a : 28              >            plp
                        
2e5b : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2e5e : 08              >            php         ;save flags
2e5f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e64 : 68              >            pla         ;load status
                       >            eor_flag 0
2e65 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e67 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e6c : ca                       dex
2e6d : 10e5                     bpl tand8
2e6f : a203                     ldx #3
2e71 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e71 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e73 : 48              >            pha         ;use stack to load status
2e74 : bd5a02          >            lda absANa,x    ;precharge accu
2e77 : 28              >            plp
                        
2e78 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e7b : 08              >            php         ;save flags
2e7c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e81 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e82 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e84 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e89 : ca                       dex
2e8a : 10e5                     bpl tand9
                        
2e8c : a003                     ldy #3      ;abs,y
2e8e :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e8e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e90 : 48              >            pha         ;use stack to load status
2e91 : b95a02          >            lda absANa,y    ;precharge accu
2e94 : 28              >            plp
                        
2e95 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e98 : 08              >            php         ;save flags
2e99 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e9e : 68              >            pla         ;load status
                       >            eor_flag 0
2e9f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ea1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ea4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ea6 : 88                       dey
2ea7 : 10e5                     bpl tand10
2ea9 : a003                     ldy #3
2eab :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2eab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ead : 48              >            pha         ;use stack to load status
2eae : b95a02          >            lda absANa,y    ;precharge accu
2eb1 : 28              >            plp
                        
2eb2 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2eb5 : 08              >            php         ;save flags
2eb6 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2eb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ebb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ebc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ebe : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ec1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ec3 : 88                       dey
2ec4 : 10e5                     bpl tand11
                        
2ec6 : a206                     ldx #6      ;(zp,x)
2ec8 : a003                     ldy #3
2eca :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2eca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ecc : 48              >            pha         ;use stack to load status
2ecd : b95a02          >            lda absANa,y    ;precharge accu
2ed0 : 28              >            plp
                        
2ed1 : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2ed3 : 08              >            php         ;save flags
2ed4 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ed7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ed9 : 68              >            pla         ;load status
                       >            eor_flag 0
2eda : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2edc : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2edf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee1 : ca                       dex
2ee2 : ca                       dex
2ee3 : 88                       dey
2ee4 : 10e4                     bpl tand12
2ee6 : a206                     ldx #6
2ee8 : a003                     ldy #3
2eea :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2eea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2eec : 48              >            pha         ;use stack to load status
2eed : b95a02          >            lda absANa,y    ;precharge accu
2ef0 : 28              >            plp
                        
2ef1 : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2ef3 : 08              >            php         ;save flags
2ef4 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ef7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ef9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2efa : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2efc : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f01 : ca                       dex
2f02 : ca                       dex
2f03 : 88                       dey
2f04 : 10e4                     bpl tand13
                        
2f06 : a003                     ldy #3      ;(zp),y
2f08 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2f08 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f0a : 48              >            pha         ;use stack to load status
2f0b : b95a02          >            lda absANa,y    ;precharge accu
2f0e : 28              >            plp
                        
2f0f : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2f11 : 08              >            php         ;save flags
2f12 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f17 : 68              >            pla         ;load status
                       >            eor_flag 0
2f18 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f1a : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f1f : 88                       dey
2f20 : 10e6                     bpl tand14
2f22 : a003                     ldy #3
2f24 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2f24 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f26 : 48              >            pha         ;use stack to load status
2f27 : b95a02          >            lda absANa,y    ;precharge accu
2f2a : 28              >            plp
                        
2f2b : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2f2d : 08              >            php         ;save flags
2f2e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f33 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f34 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f36 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f3b : 88                       dey
2f3c : 10e6                     bpl tand15
                                next_test
2f3e : ad0002          >            lda test_case   ;previous test
2f41 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2f43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2f45 : a927            >            lda #test_num   ;*** next tests' number
2f47 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2f4a : a203                     ldx #3          ;immediate - self modifying code
2f4c : b520             teor    lda zpEO,x
2f4e : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2f51 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f53 : 48              >            pha         ;use stack to load status
2f54 : bd5e02          >            lda absEOa,x    ;precharge accu
2f57 : 28              >            plp
                        
2f58 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2f5b : 08              >            php         ;save flags
2f5c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f61 : 68              >            pla         ;load status
                       >            eor_flag 0
2f62 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f64 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f69 : ca                       dex
2f6a : 10e0                     bpl teor
2f6c : a203                     ldx #3
2f6e : b520             teor1   lda zpEO,x
2f70 : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f73 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f75 : 48              >            pha         ;use stack to load status
2f76 : bd5e02          >            lda absEOa,x    ;precharge accu
2f79 : 28              >            plp
                        
2f7a : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2f7d : 08              >            php         ;save flags
2f7e : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f83 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f84 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f86 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f8b : ca                       dex
2f8c : 10e0                     bpl teor1
                            
2f8e : a203                     ldx #3      ;zp
2f90 : b520             teor2    lda zpEO,x
2f92 : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f94 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f96 : 48              >            pha         ;use stack to load status
2f97 : bd5e02          >            lda absEOa,x    ;precharge accu
2f9a : 28              >            plp
                        
2f9b : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
2f9d : 08              >            php         ;save flags
2f9e : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fa1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fa3 : 68              >            pla         ;load status
                       >            eor_flag 0
2fa4 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fa6 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fa9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fab : ca                       dex
2fac : 10e2                     bpl teor2
2fae : a203                     ldx #3
2fb0 : b520             teor3   lda zpEO,x
2fb2 : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fb4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fb6 : 48              >            pha         ;use stack to load status
2fb7 : bd5e02          >            lda absEOa,x    ;precharge accu
2fba : 28              >            plp
                        
2fbb : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2fbd : 08              >            php         ;save flags
2fbe : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fc3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fc4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fc6 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fcb : ca                       dex
2fcc : 10e2                     bpl teor3
                        
2fce : a203                     ldx #3      ;abs
2fd0 : b520             teor4   lda zpEO,x
2fd2 : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2fd5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fd7 : 48              >            pha         ;use stack to load status
2fd8 : bd5e02          >            lda absEOa,x    ;precharge accu
2fdb : 28              >            plp
                        
2fdc : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2fdf : 08              >            php         ;save flags
2fe0 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fe3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fe5 : 68              >            pla         ;load status
                       >            eor_flag 0
2fe6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fe8 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2feb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fed : ca                       dex
2fee : 10e0                     bpl teor4
2ff0 : a203                     ldx #3
2ff2 : b520             teor5   lda zpEO,x
2ff4 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2ff7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ff9 : 48              >            pha         ;use stack to load status
2ffa : bd5e02          >            lda absEOa,x    ;precharge accu
2ffd : 28              >            plp
                        
2ffe : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
3001 : 08              >            php         ;save flags
3002 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3005 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3007 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3008 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
300a : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
300d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
300f : ca                       dex
3010 : 1002                     bpl teor6
                        
3012 : a203                     ldx #3      ;zp,x
3014 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
3014 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3016 : 48              >            pha         ;use stack to load status
3017 : bd5e02          >            lda absEOa,x    ;precharge accu
301a : 28              >            plp
                        
301b : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
301d : 08              >            php         ;save flags
301e : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3021 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3023 : 68              >            pla         ;load status
                       >            eor_flag 0
3024 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3026 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3029 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
302b : ca                       dex
302c : 10e6                     bpl teor6
302e : a203                     ldx #3
3030 :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3030 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3032 : 48              >            pha         ;use stack to load status
3033 : bd5e02          >            lda absEOa,x    ;precharge accu
3036 : 28              >            plp
                        
3037 : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3039 : 08              >            php         ;save flags
303a : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
303d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
303f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3040 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3042 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3045 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3047 : ca                       dex
3048 : 10e6                     bpl teor7
                        
304a : a203                     ldx #3      ;abs,x
304c :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
304c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
304e : 48              >            pha         ;use stack to load status
304f : bd5e02          >            lda absEOa,x    ;precharge accu
3052 : 28              >            plp
                        
3053 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3056 : 08              >            php         ;save flags
3057 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
305a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
305c : 68              >            pla         ;load status
                       >            eor_flag 0
305d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
305f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3062 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3064 : ca                       dex
3065 : 10e5                     bpl teor8
3067 : a203                     ldx #3
3069 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3069 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
306b : 48              >            pha         ;use stack to load status
306c : bd5e02          >            lda absEOa,x    ;precharge accu
306f : 28              >            plp
                        
3070 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3073 : 08              >            php         ;save flags
3074 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3077 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3079 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
307a : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
307c : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
307f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3081 : ca                       dex
3082 : 10e5                     bpl teor9
                        
3084 : a003                     ldy #3      ;abs,y
3086 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3086 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3088 : 48              >            pha         ;use stack to load status
3089 : b95e02          >            lda absEOa,y    ;precharge accu
308c : 28              >            plp
                        
308d : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
3090 : 08              >            php         ;save flags
3091 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3094 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3096 : 68              >            pla         ;load status
                       >            eor_flag 0
3097 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3099 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
309c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
309e : 88                       dey
309f : 10e5                     bpl teor10
30a1 : a003                     ldy #3
30a3 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30a5 : 48              >            pha         ;use stack to load status
30a6 : b95e02          >            lda absEOa,y    ;precharge accu
30a9 : 28              >            plp
                        
30aa : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
30ad : 08              >            php         ;save flags
30ae : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30b3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30b4 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30b6 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30bb : 88                       dey
30bc : 10e5                     bpl teor11
                        
30be : a206                     ldx #6      ;(zp,x)
30c0 : a003                     ldy #3
30c2 :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
30c2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30c4 : 48              >            pha         ;use stack to load status
30c5 : b95e02          >            lda absEOa,y    ;precharge accu
30c8 : 28              >            plp
                        
30c9 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
30cb : 08              >            php         ;save flags
30cc : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30d1 : 68              >            pla         ;load status
                       >            eor_flag 0
30d2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30d4 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30d9 : ca                       dex
30da : ca                       dex
30db : 88                       dey
30dc : 10e4                     bpl teor12
30de : a206                     ldx #6
30e0 : a003                     ldy #3
30e2 :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30e4 : 48              >            pha         ;use stack to load status
30e5 : b95e02          >            lda absEOa,y    ;precharge accu
30e8 : 28              >            plp
                        
30e9 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
30eb : 08              >            php         ;save flags
30ec : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30f1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30f2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30f4 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30f9 : ca                       dex
30fa : ca                       dex
30fb : 88                       dey
30fc : 10e4                     bpl teor13
                        
30fe : a003                     ldy #3      ;(zp),y
3100 :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
3100 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3102 : 48              >            pha         ;use stack to load status
3103 : b95e02          >            lda absEOa,y    ;precharge accu
3106 : 28              >            plp
                        
3107 : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
3109 : 08              >            php         ;save flags
310a : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
310d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
310f : 68              >            pla         ;load status
                       >            eor_flag 0
3110 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3112 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3115 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3117 : 88                       dey
3118 : 10e6                     bpl teor14
311a : a003                     ldy #3
311c :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
311c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
311e : 48              >            pha         ;use stack to load status
311f : b95e02          >            lda absEOa,y    ;precharge accu
3122 : 28              >            plp
                        
3123 : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
3125 : 08              >            php         ;save flags
3126 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3129 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
312b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
312c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
312e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3131 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3133 : 88                       dey
3134 : 10e6                     bpl teor15
                                next_test
3136 : ad0002          >            lda test_case   ;previous test
3139 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
313b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
313d : a928            >            lda #test_num   ;*** next tests' number
313f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
3142 : a203                     ldx #3          ;immediate - self modifying code
3144 : b518             tora    lda zpOR,x
3146 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
3149 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
314b : 48              >            pha         ;use stack to load status
314c : bd5602          >            lda absORa,x    ;precharge accu
314f : 28              >            plp
                        
3150 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3153 : 08              >            php         ;save flags
3154 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3157 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3159 : 68              >            pla         ;load status
                       >            eor_flag 0
315a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
315c : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
315f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3161 : ca                       dex
3162 : 10e0                     bpl tora
3164 : a203                     ldx #3
3166 : b518             tora1   lda zpOR,x
3168 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
316b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
316d : 48              >            pha         ;use stack to load status
316e : bd5602          >            lda absORa,x    ;precharge accu
3171 : 28              >            plp
                        
3172 : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3175 : 08              >            php         ;save flags
3176 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3179 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
317b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
317c : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
317e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3181 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3183 : ca                       dex
3184 : 10e0                     bpl tora1
                            
3186 : a203                     ldx #3      ;zp
3188 : b518             tora2   lda zpOR,x
318a : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
318c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
318e : 48              >            pha         ;use stack to load status
318f : bd5602          >            lda absORa,x    ;precharge accu
3192 : 28              >            plp
                        
3193 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
3195 : 08              >            php         ;save flags
3196 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3199 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
319b : 68              >            pla         ;load status
                       >            eor_flag 0
319c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
319e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31a3 : ca                       dex
31a4 : 10e2                     bpl tora2
31a6 : a203                     ldx #3
31a8 : b518             tora3   lda zpOR,x
31aa : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
31ac : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31ae : 48              >            pha         ;use stack to load status
31af : bd5602          >            lda absORa,x    ;precharge accu
31b2 : 28              >            plp
                        
31b3 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
31b5 : 08              >            php         ;save flags
31b6 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31bb : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31bc : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31be : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31c3 : ca                       dex
31c4 : 10e2                     bpl tora3
                        
31c6 : a203                     ldx #3      ;abs
31c8 : b518             tora4   lda zpOR,x
31ca : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
31cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31cf : 48              >            pha         ;use stack to load status
31d0 : bd5602          >            lda absORa,x    ;precharge accu
31d3 : 28              >            plp
                        
31d4 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
31d7 : 08              >            php         ;save flags
31d8 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31dd : 68              >            pla         ;load status
                       >            eor_flag 0
31de : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31e0 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31e5 : ca                       dex
31e6 : 10e0                     bpl tora4
31e8 : a203                     ldx #3
31ea : b518             tora5   lda zpOR,x
31ec : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
31ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31f1 : 48              >            pha         ;use stack to load status
31f2 : bd5602          >            lda absORa,x    ;precharge accu
31f5 : 28              >            plp
                        
31f6 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
31f9 : 08              >            php         ;save flags
31fa : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ff : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3200 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3202 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3205 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3207 : ca                       dex
3208 : 1002                     bpl tora6
                        
320a : a203                     ldx #3      ;zp,x
320c :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
320c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
320e : 48              >            pha         ;use stack to load status
320f : bd5602          >            lda absORa,x    ;precharge accu
3212 : 28              >            plp
                        
3213 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
3215 : 08              >            php         ;save flags
3216 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3219 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
321b : 68              >            pla         ;load status
                       >            eor_flag 0
321c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
321e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3221 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3223 : ca                       dex
3224 : 10e6                     bpl tora6
3226 : a203                     ldx #3
3228 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
3228 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
322a : 48              >            pha         ;use stack to load status
322b : bd5602          >            lda absORa,x    ;precharge accu
322e : 28              >            plp
                        
322f : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3231 : 08              >            php         ;save flags
3232 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3235 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3237 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3238 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
323a : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
323d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
323f : ca                       dex
3240 : 10e6                     bpl tora7
                        
3242 : a203                     ldx #3      ;abs,x
3244 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3244 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3246 : 48              >            pha         ;use stack to load status
3247 : bd5602          >            lda absORa,x    ;precharge accu
324a : 28              >            plp
                        
324b : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
324e : 08              >            php         ;save flags
324f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3252 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3254 : 68              >            pla         ;load status
                       >            eor_flag 0
3255 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3257 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
325a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
325c : ca                       dex
325d : 10e5                     bpl tora8
325f : a203                     ldx #3
3261 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
3261 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3263 : 48              >            pha         ;use stack to load status
3264 : bd5602          >            lda absORa,x    ;precharge accu
3267 : 28              >            plp
                        
3268 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
326b : 08              >            php         ;save flags
326c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
326f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3271 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3272 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3274 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3277 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3279 : ca                       dex
327a : 10e5                     bpl tora9
                        
327c : a003                     ldy #3      ;abs,y
327e :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
327e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3280 : 48              >            pha         ;use stack to load status
3281 : b95602          >            lda absORa,y    ;precharge accu
3284 : 28              >            plp
                        
3285 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3288 : 08              >            php         ;save flags
3289 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
328c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
328e : 68              >            pla         ;load status
                       >            eor_flag 0
328f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3291 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3294 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3296 : 88                       dey
3297 : 10e5                     bpl tora10
3299 : a003                     ldy #3
329b :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
329b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
329d : 48              >            pha         ;use stack to load status
329e : b95602          >            lda absORa,y    ;precharge accu
32a1 : 28              >            plp
                        
32a2 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
32a5 : 08              >            php         ;save flags
32a6 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32ab : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32ac : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32ae : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32b3 : 88                       dey
32b4 : 10e5                     bpl tora11
                        
32b6 : a206                     ldx #6      ;(zp,x)
32b8 : a003                     ldy #3
32ba :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
32ba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32bc : 48              >            pha         ;use stack to load status
32bd : b95602          >            lda absORa,y    ;precharge accu
32c0 : 28              >            plp
                        
32c1 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
32c3 : 08              >            php         ;save flags
32c4 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32c9 : 68              >            pla         ;load status
                       >            eor_flag 0
32ca : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32cc : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32d1 : ca                       dex
32d2 : ca                       dex
32d3 : 88                       dey
32d4 : 10e4                     bpl tora12
32d6 : a206                     ldx #6
32d8 : a003                     ldy #3
32da :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
32da : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
32dc : 48              >            pha         ;use stack to load status
32dd : b95602          >            lda absORa,y    ;precharge accu
32e0 : 28              >            plp
                        
32e1 : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
32e3 : 08              >            php         ;save flags
32e4 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32e9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32ea : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32ec : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32f1 : ca                       dex
32f2 : ca                       dex
32f3 : 88                       dey
32f4 : 10e4                     bpl tora13
                        
32f6 : a003                     ldy #3      ;(zp),y
32f8 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
32f8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32fa : 48              >            pha         ;use stack to load status
32fb : b95602          >            lda absORa,y    ;precharge accu
32fe : 28              >            plp
                        
32ff : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
3301 : 08              >            php         ;save flags
3302 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3305 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3307 : 68              >            pla         ;load status
                       >            eor_flag 0
3308 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
330a : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
330d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
330f : 88                       dey
3310 : 10e6                     bpl tora14
3312 : a003                     ldy #3
3314 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
3314 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3316 : 48              >            pha         ;use stack to load status
3317 : b95602          >            lda absORa,y    ;precharge accu
331a : 28              >            plp
                        
331b : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
331d : 08              >            php         ;save flags
331e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3321 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3323 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3324 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3326 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3329 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
332b : 88                       dey
332c : 10e6                     bpl tora15
                            if I_flag = 3
332e : 58                       cli
                            endif                
                                next_test
332f : ad0002          >            lda test_case   ;previous test
3332 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3334 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
3336 : a929            >            lda #test_num   ;*** next tests' number
3338 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
333b : d8                       cld
333c : a20e                     ldx #ad2        ;for indexed test
333e : a0ff                     ldy #$ff        ;max range
3340 : a900                     lda #0          ;start with adding zeroes & no carry
3342 : 850c                     sta adfc        ;carry in - for diag
3344 : 850d                     sta ad1         ;operand 1 - accumulator
3346 : 850e                     sta ad2         ;operand 2 - memory or immediate
3348 : 8d0302                   sta ada2        ;non zp
334b : 850f                     sta adrl        ;expected result bits 0-7
334d : 8510                     sta adrh        ;expected result bit 8 (carry out)
334f : a9ff                     lda #$ff        ;complemented operand 2 for subtract
3351 : 8512                     sta sb2
3353 : 8d0402                   sta sba2        ;non zp
3356 : a902                     lda #2          ;expected Z-flag
3358 : 8511                     sta adrf
335a : 18               tadd    clc             ;test with carry clear
335b : 20e233                   jsr chkadd
335e : e60c                     inc adfc        ;now with carry
3360 : e60f                     inc adrl        ;result +1
3362 : 08                       php             ;save N & Z from low result
3363 : 08                       php
3364 : 68                       pla             ;accu holds expected flags
3365 : 2982                     and #$82        ;mask N & Z
3367 : 28                       plp
3368 : d002                     bne tadd1
336a : e610                     inc adrh        ;result bit 8 - carry
336c : 0510             tadd1   ora adrh        ;merge C to expected flags
336e : 8511                     sta adrf        ;save expected flags except overflow
3370 : 38                       sec             ;test with carry set
3371 : 20e233                   jsr chkadd
3374 : c60c                     dec adfc        ;same for operand +1 but no carry
3376 : e60d                     inc ad1
3378 : d0e0                     bne tadd        ;iterate op1
337a : a900                     lda #0          ;preset result to op2 when op1 = 0
337c : 8510                     sta adrh
337e : ee0302                   inc ada2
3381 : e60e                     inc ad2
3383 : 08                       php             ;save NZ as operand 2 becomes the new result
3384 : 68                       pla
3385 : 2982                     and #$82        ;mask N00000Z0
3387 : 8511                     sta adrf        ;no need to check carry as we are adding to 0
3389 : c612                     dec sb2         ;complement subtract operand 2
338b : ce0402                   dec sba2
338e : a50e                     lda ad2         
3390 : 850f                     sta adrl
3392 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3394 : ad0002                   lda test_case
3397 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3399 : d0fe            >        bne *           ;failed not equal (non zero)
                        
339b : a9f0                     lda #$f0        ;mark opcode testing complete
339d : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
33a0 : d8              >            cld
33a1 : a900            >            lda #0
33a3 : 850c            >            sta zpt         ;set low byte of indirect pointer
33a5 : 850f            >            sta zpt+3       ;checksum high byte
                       >          if disable_selfmod = 0
33a7 : 8d1905          >            sta range_adr   ;reset self modifying code
                       >          endif
33aa : 18              >            clc
33ab : a209            >            ldx #zp_bss-zero_page ;zeropage - write test area
33ad : 750a            >ccs32410      adc zero_page,x
33af : 9003            >            bcc ccs22410
33b1 : e60f            >            inc zpt+3       ;carry to high byte
33b3 : 18              >            clc
33b4 : e8              >ccs22410      inx
33b5 : d0f6            >            bne ccs32410
33b7 : a202            >            ldx #hi(abs1)   ;set high byte of indirect pointer
33b9 : 860d            >            stx zpt+1
33bb : a017            >            ldy #lo(abs1)   ;data after write & execute test area
33bd : 710c            >ccs52410      adc (zpt),y
33bf : 9003            >            bcc ccs42410
33c1 : e60f            >            inc zpt+3       ;carry to high byte
33c3 : 18              >            clc
33c4 : c8              >ccs42410      iny
33c5 : d0f6            >            bne ccs52410
33c7 : e8              >            inx             ;advance RAM high address
33c8 : 860d            >            stx zpt+1
33ca : e000            >            cpx #ram_top
33cc : d0ef            >            bne ccs52410
33ce : 850e            >            sta zpt+2       ;checksum low is
33d0 : cd0102          >            cmp ram_chksm   ;checksum low expected
                       >            trap_ne         ;checksum mismatch
33d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33d5 : a50f            >            lda zpt+3       ;checksum high is
33d7 : cd0202          >            cmp ram_chksm+1 ;checksum high expected
                       >            trap_ne         ;checksum mismatch
33da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
33dc : 4cdc33          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
33df : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
33e2 : a511             chkadd  lda adrf        ;add V-flag if overflow
33e4 : 2983                     and #$83        ;keep N-----ZC / clear V
33e6 : 48                       pha
33e7 : a50d                     lda ad1         ;test sign unequal between operands
33e9 : 450e                     eor ad2
33eb : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
33ed : a50d                     lda ad1         ;test sign equal between operands and result
33ef : 450f                     eor adrl
33f1 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
33f3 : 68                       pla
33f4 : 0940                     ora #$40        ;set V
33f6 : 48                       pha
33f7 : 68               ckad1   pla
33f8 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
33fa : 08                       php             ;save carry for subtract
33fb : a50d                     lda ad1
33fd : 650e                     adc ad2         ;perform add
33ff : 08                       php          
3400 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3402 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3404 : 68                       pla             ;check flags
3405 : 29c3                     and #$c3        ;mask NV----ZC
3407 : c511                     cmp adrf
                                trap_ne         ;bad flags
3409 : d0fe            >        bne *           ;failed not equal (non zero)
                        
340b : 28                       plp
340c : 08                       php             ;save carry for next add
340d : a50d                     lda ad1
340f : e512                     sbc sb2         ;perform subtract
3411 : 08                       php          
3412 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3414 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3416 : 68                       pla             ;check flags
3417 : 29c3                     and #$c3        ;mask NV----ZC
3419 : c511                     cmp adrf
                                trap_ne         ;bad flags
341b : d0fe            >        bne *           ;failed not equal (non zero)
                        
341d : 28                       plp
                        ; binary ADC / SBC abs
341e : 08                       php             ;save carry for subtract
341f : a50d                     lda ad1
3421 : 6d0302                   adc ada2        ;perform add
3424 : 08                       php          
3425 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3427 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3429 : 68                       pla             ;check flags
342a : 29c3                     and #$c3        ;mask NV----ZC
342c : c511                     cmp adrf
                                trap_ne         ;bad flags
342e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3430 : 28                       plp
3431 : 08                       php             ;save carry for next add
3432 : a50d                     lda ad1
3434 : ed0402                   sbc sba2        ;perform subtract
3437 : 08                       php          
3438 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
343a : d0fe            >        bne *           ;failed not equal (non zero)
                        
343c : 68                       pla             ;check flags
343d : 29c3                     and #$c3        ;mask NV----ZC
343f : c511                     cmp adrf
                                trap_ne         ;bad flags
3441 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3443 : 28                       plp
                        ; binary ADC / SBC #
3444 : 08                       php             ;save carry for subtract
3445 : a50e                     lda ad2
3447 : 8d1202                   sta ex_adci+1   ;set ADC # operand
344a : a50d                     lda ad1
344c : 201102                   jsr ex_adci     ;execute ADC # in RAM
344f : 08                       php          
3450 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3454 : 68                       pla             ;check flags
3455 : 29c3                     and #$c3        ;mask NV----ZC
3457 : c511                     cmp adrf
                                trap_ne         ;bad flags
3459 : d0fe            >        bne *           ;failed not equal (non zero)
                        
345b : 28                       plp
345c : 08                       php             ;save carry for next add
345d : a512                     lda sb2
345f : 8d1502                   sta ex_sbci+1   ;set SBC # operand
3462 : a50d                     lda ad1
3464 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
3467 : 08                       php          
3468 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
346a : d0fe            >        bne *           ;failed not equal (non zero)
                        
346c : 68                       pla             ;check flags
346d : 29c3                     and #$c3        ;mask NV----ZC
346f : c511                     cmp adrf
                                trap_ne         ;bad flags
3471 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3473 : 28                       plp
                        ; binary ADC / SBC zp,x
3474 : 08                       php             ;save carry for subtract
3475 : a50d                     lda ad1
3477 : 7500                     adc 0,x         ;perform add
3479 : 08                       php          
347a : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
347c : d0fe            >        bne *           ;failed not equal (non zero)
                        
347e : 68                       pla             ;check flags
347f : 29c3                     and #$c3        ;mask NV----ZC
3481 : c511                     cmp adrf
                                trap_ne         ;bad flags
3483 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3485 : 28                       plp
3486 : 08                       php             ;save carry for next add
3487 : a50d                     lda ad1
3489 : f504                     sbc sb2-ad2,x   ;perform subtract
348b : 08                       php          
348c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
348e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3490 : 68                       pla             ;check flags
3491 : 29c3                     and #$c3        ;mask NV----ZC
3493 : c511                     cmp adrf
                                trap_ne         ;bad flags
3495 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3497 : 28                       plp
                        ; binary ADC / SBC abs,x
3498 : 08                       php             ;save carry for subtract
3499 : a50d                     lda ad1
349b : 7df501                   adc ada2-ad2,x  ;perform add
349e : 08                       php          
349f : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a3 : 68                       pla             ;check flags
34a4 : 29c3                     and #$c3        ;mask NV----ZC
34a6 : c511                     cmp adrf
                                trap_ne         ;bad flags
34a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34aa : 28                       plp
34ab : 08                       php             ;save carry for next add
34ac : a50d                     lda ad1
34ae : fdf601                   sbc sba2-ad2,x  ;perform subtract
34b1 : 08                       php          
34b2 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b6 : 68                       pla             ;check flags
34b7 : 29c3                     and #$c3        ;mask NV----ZC
34b9 : c511                     cmp adrf
                                trap_ne         ;bad flags
34bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
34bd : 28                       plp
                        ; binary ADC / SBC abs,y
34be : 08                       php             ;save carry for subtract
34bf : a50d                     lda ad1
34c1 : 790401                   adc ada2-$ff,y  ;perform add
34c4 : 08                       php          
34c5 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c9 : 68                       pla             ;check flags
34ca : 29c3                     and #$c3        ;mask NV----ZC
34cc : c511                     cmp adrf
                                trap_ne         ;bad flags
34ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d0 : 28                       plp
34d1 : 08                       php             ;save carry for next add
34d2 : a50d                     lda ad1
34d4 : f90501                   sbc sba2-$ff,y  ;perform subtract
34d7 : 08                       php          
34d8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34da : d0fe            >        bne *           ;failed not equal (non zero)
                        
34dc : 68                       pla             ;check flags
34dd : 29c3                     and #$c3        ;mask NV----ZC
34df : c511                     cmp adrf
                                trap_ne         ;bad flags
34e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34e3 : 28                       plp
                        ; binary ADC / SBC (zp,x)
34e4 : 08                       php             ;save carry for subtract
34e5 : a50d                     lda ad1
34e7 : 6144                     adc (lo adi2-ad2,x) ;perform add
34e9 : 08                       php          
34ea : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ee : 68                       pla             ;check flags
34ef : 29c3                     and #$c3        ;mask NV----ZC
34f1 : c511                     cmp adrf
                                trap_ne         ;bad flags
34f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f5 : 28                       plp
34f6 : 08                       php             ;save carry for next add
34f7 : a50d                     lda ad1
34f9 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
34fb : 08                       php          
34fc : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
3500 : 68                       pla             ;check flags
3501 : 29c3                     and #$c3        ;mask NV----ZC
3503 : c511                     cmp adrf
                                trap_ne         ;bad flags
3505 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3507 : 28                       plp
                        ; binary ADC / SBC (abs),y
3508 : 08                       php             ;save carry for subtract
3509 : a50d                     lda ad1
350b : 7156                     adc (adiy2),y   ;perform add
350d : 08                       php          
350e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3510 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3512 : 68                       pla             ;check flags
3513 : 29c3                     and #$c3        ;mask NV----ZC
3515 : c511                     cmp adrf
                                trap_ne         ;bad flags
3517 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3519 : 28                       plp
351a : 08                       php             ;save carry for next add
351b : a50d                     lda ad1
351d : f158                     sbc (sbiy2),y   ;perform subtract
351f : 08                       php          
3520 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3522 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3524 : 68                       pla             ;check flags
3525 : 29c3                     and #$c3        ;mask NV----ZC
3527 : c511                     cmp adrf
                                trap_ne         ;bad flags
3529 : d0fe            >        bne *           ;failed not equal (non zero)
                        
352b : 28                       plp
352c : 60                       rts
                        
                        ; target for the jump absolute test
352d : 88                       dey
352e : 88                       dey
352f :                  test_far
352f : 08                       php             ;either SP or Y count will fail, if we do not hit
3530 : 88                       dey
3531 : 88                       dey
3532 : 88                       dey
3533 : 28                       plp
                                trap_cs         ;flags loaded?
3534 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3536 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3538 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
353a : f0fe            >        beq *           ;failed equal (zero)
                        
353c : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
353e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3540 : e041                     cpx #'A'
                                trap_ne        
3542 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3544 : c04f                     cpy #('R'-3)
                                trap_ne
3546 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3548 : 48                       pha             ;save a,x
3549 : 8a                       txa
354a : 48                       pha
354b : ba                       tsx
354c : e0fd                     cpx #$fd        ;check SP
                                trap_ne
354e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3550 : 68                       pla             ;restore x
3551 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3552 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3554 : 48              >            pha         ;use stack to load status
3555 : 28              >            plp
                        
3556 : 68                       pla             ;restore a
3557 : e8                       inx             ;return registers with modifications
3558 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
355a : 4c4209                   jmp far_ret
                                
                        ; target for the jump indirect test
355d : 00                       align
355e : 6735             ptr_tst_ind dw test_ind
3560 : 9709             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
3562 : 4c6235          >        jmp *           ;failed anyway
                        
3565 : 88                       dey
3566 : 88                       dey
3567 :                  test_ind
3567 : 08                       php             ;either SP or Y count will fail, if we do not hit
3568 : 88                       dey
3569 : 88                       dey
356a : 88                       dey
356b : 28                       plp
                                trap_cs         ;flags loaded?
356c : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
356e : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3570 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3572 : f0fe            >        beq *           ;failed equal (zero)
                        
3574 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3576 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3578 : e04e                     cpx #'N'
                                trap_ne        
357a : d0fe            >        bne *           ;failed not equal (non zero)
                        
357c : c041                     cpy #('D'-3)
                                trap_ne
357e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3580 : 48                       pha             ;save a,x
3581 : 8a                       txa
3582 : 48                       pha
3583 : ba                       tsx
3584 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3586 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3588 : 68                       pla             ;restore x
3589 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
358a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
358c : 48              >            pha         ;use stack to load status
358d : 28              >            plp
                        
358e : 68                       pla             ;restore a
358f : e8                       inx             ;return registers with modifications
3590 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3592 : 6c6035                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3595 : 4c9535          >        jmp *           ;failed anyway
                        
3598 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
359b : 88                       dey
359c : 88                       dey
359d :                  test_jsr
359d : 08                       php             ;either SP or Y count will fail, if we do not hit
359e : 88                       dey
359f : 88                       dey
35a0 : 88                       dey
35a1 : 28                       plp
                                trap_cs         ;flags loaded?
35a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
35a4 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
35a6 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
35a8 : f0fe            >        beq *           ;failed equal (zero)
                        
35aa : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
35ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ae : e053                     cpx #'S'
                                trap_ne        
35b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b2 : c04f                     cpy #('R'-3)
                                trap_ne
35b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b6 : 48                       pha             ;save a,x
35b7 : 8a                       txa
35b8 : 48                       pha       
35b9 : ba                       tsx             ;sp -4? (return addr,a,x)
35ba : e0fb                     cpx #$fb
                                trap_ne
35bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
35be : adff01                   lda $1ff        ;propper return on stack
35c1 : c909                     cmp #hi(jsr_ret)
                                trap_ne
35c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c5 : adfe01                   lda $1fe
35c8 : c9cd                     cmp #lo(jsr_ret)
                                trap_ne
35ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
35cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
35ce : 48              >            pha         ;use stack to load status
35cf : 28              >            plp
                        
35d0 : 68                       pla             ;pull x,a
35d1 : aa                       tax
35d2 : 68                       pla
35d3 : e8                       inx             ;return registers with modifications
35d4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
35d6 : 60                       rts
                                trap            ;runover protection
35d7 : 4cd735          >        jmp *           ;failed anyway
                        
35da : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
35dd :                  nmi_trap
                                trap            ;check stack for conditions at NMI
35dd : 4cdd35          >        jmp *           ;failed anyway
                        
35e0 : 4c0004                   jmp start       ;catastrophic error - cannot continue
35e3 :                  res_trap
                                trap            ;unexpected RESET
35e3 : 4ce335          >        jmp *           ;failed anyway
                        
35e6 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
35e9 : 88                       dey
35ea : 88                       dey
35eb :                  irq_trap                ;BRK test or unextpected BRK or IRQ
35eb : 08                       php             ;either SP or Y count will fail, if we do not hit
35ec : 88                       dey
35ed : 88                       dey
35ee : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
35ef : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
35f1 : f042                     beq break2
35f3 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
35f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f7 : e052                     cpx #'R'
                                trap_ne        
35f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35fb : c048                     cpy #'K'-3
                                trap_ne
35fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ff : 850a                     sta irq_a       ;save registers during break test
3601 : 860b                     stx irq_x
3603 : ba                       tsx             ;test break on stack
3604 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
3607 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
360b : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
360c : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
360e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3610 : ba                       tsx
3611 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3613 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3615 : adff01                   lda $1ff        ;propper return on stack
3618 : c90a                     cmp #hi(brk_ret0)
                                trap_ne
361a : d0fe            >        bne *           ;failed not equal (non zero)
                        
361c : adfe01                   lda $1fe
361f : c904                     cmp #lo(brk_ret0)
                                trap_ne
3621 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
3623 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
3625 : 48                       pha
3626 : a60b                     ldx irq_x
3628 : e8                       inx             ;return registers with modifications
3629 : a50a                     lda irq_a
362b : 49aa                     eor #$aa
362d : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
362e : 40                       rti
                                trap            ;runover protection
362f : 4c2f36          >        jmp *           ;failed anyway
                        
3632 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
3635 :                  break2                  ;BRK pass 2        
3635 : e0ad                     cpx #$ff-'R'
                                trap_ne        
3637 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3639 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
363b : d0fe            >        bne *           ;failed not equal (non zero)
                        
363d : 850a                     sta irq_a       ;save registers during break test
363f : 860b                     stx irq_x
3641 : ba                       tsx             ;test break on stack
3642 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
3645 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
3647 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3649 : 68                       pla
364a : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
364c : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
364e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3650 : ba                       tsx
3651 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3653 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3655 : adff01                   lda $1ff        ;propper return on stack
3658 : c90a                     cmp #hi(brk_ret1)
                                trap_ne
365a : d0fe            >        bne *           ;failed not equal (non zero)
                        
365c : adfe01                   lda $1fe
365f : c92a                     cmp #lo(brk_ret1)
                                trap_ne
3661 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
3663 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
3665 : 48                       pha      
3666 : a60b                     ldx irq_x
3668 : e8                       inx             ;return registers with modifications
3669 : a50a                     lda irq_a
366b : 49aa                     eor #$aa
366d : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
366e : 40                       rti
                                trap            ;runover protection
366f : 4c6f36          >        jmp *           ;failed anyway
                        
3672 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : dd35                     dw  nmi_trap
fffc : e335                     dw  res_trap
fffe : eb35                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
                        
No errors in pass 2.
Wrote binary from address $000a through $ffff.
Total size 65526 bytes.
Program start address is at $0400 (1024).
